<!DOCTYPE html>
<html lang="sv" data-theme="light">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>CarbonAra - Secure Certificate Environment</title>

  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com"/>
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin/>
  <link href="https://fonts.googleapis.com/css2?family=Great+Vibes&family=Montserrat:wght@400;500;700&display=swap" rel="stylesheet"/>

  <!-- Core libs -->
  <script src="https://unpkg.com/pdf-lib/dist/pdf-lib.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/qrious/dist/qrious.min.js"></script>

  <style>
    :root{
      --bg-color:#f8f9fa;--fg-color:#ffffff;--text-color:#212529;
      --text-light-color:#6c757d;--border-color:#dee2e6;--primary-color:#0d6efd;
      --primary-hover-color:#0b5ed7;--header-bg:#ffffff;--shadow-color:rgba(0,0,0,.05);
      --success-color:#198754;--warning-color:#ffc107;--danger-color:#dc3545;
      --font-main:'Montserrat',sans-serif;--font-display:'Great Vibes',cursive;
    }
    [data-theme="dark"]{
      --bg-color:#121212;--fg-color:#1e1e1e;--text-color:#e0e0e0;
      --text-light-color:#8e8e8e;--border-color:#3a3a3a;--primary-color:#4dabf7;
      --primary-hover-color:#74c0fc;--header-bg:#1e1e1e;--shadow-color:rgba(0,0,0,.3);
    }
    *,*::before,*::after{box-sizing:border-box}
    body{font-family:var(--font-main);margin:0;background:var(--bg-color);color:var(--text-color);transition:background-color .3s,color .3s;font-size:14px;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;overflow:hidden}

    .header{display:flex;justify-content:space-between;align-items:center;padding:12px 30px;background:var(--header-bg);border-bottom:1px solid var(--border-color);box-shadow:0 2px 8px var(--shadow-color);position:sticky;top:0;z-index:100}
    .logo{display:flex;align-items:center;gap:12px}
    .logo svg{width:32px;height:32px;fill:var(--primary-color)}
    .logo h1{margin:0;font-size:22px;font-weight:700}
    .controls{display:flex;align-items:center;gap:20px}
    #theme-toggle{cursor:pointer;background:none;border:1px solid var(--border-color);border-radius:20px;padding:6px;display:flex;align-items:center;font-size:18px;line-height:1;transition:transform .2s,background-color .2s}
    #theme-toggle:hover{transform:scale(1.1);background:var(--bg-color)}

    .main-container{display:flex;height:calc(100vh - 65px)}
    .sidebar{width:400px;min-width:400px;padding:20px;background:var(--fg-color);border-right:1px solid var(--border-color);overflow-y:auto}
    .preview-area{flex-grow:1;padding:30px;display:flex;justify-content:center;align-items:center;overflow:auto;background:var(--bg-color)}
    .preview-frame{padding:20px;background:var(--fg-color);border-radius:8px;box-shadow:0 10px 30px var(--shadow-color);transform-origin:center center}
    #previewCanvas{border:1px solid var(--border-color);object-fit:contain;cursor:grab}
    #previewCanvas:active{cursor:grabbing}
    .preview-controls{display:flex;justify-content:space-between;align-items:center;padding:10px 0;font-size:12px;color:var(--text-light-color)}
    .zoom-controls{display:flex;align-items:center;gap:10px}
    .zoom-controls button{all:unset;cursor:pointer;padding:5px;font-weight:bold;font-size:18px}

    .tabs{display:flex;margin-bottom:20px;border-bottom:1px solid var(--border-color)}
    .tab-button{padding:12px 18px;cursor:pointer;border:none;background:none;font-size:16px;color:var(--text-light-color);border-bottom:3px solid transparent;font-weight:500}
    .tab-button.active{color:var(--primary-color);border-bottom-color:var(--primary-color)}
    .tab-content{display:none}
    .tab-content.active{display:block}

    details{margin-bottom:10px;border:1px solid var(--border-color);border-radius:5px;transition:background-color .2s}
    details:hover{background-color:rgba(128,128,128,.03)}
    summary{cursor:pointer;padding:12px;font-weight:bold;background-color:rgba(128,128,128,.05);list-style:revert}
    details[open]>summary{border-bottom:1px solid var(--border-color)}
    .details-content{padding:15px}

    .form-group{margin-bottom:18px}
    label{display:block;margin-bottom:6px;font-weight:bold;font-size:12px;text-transform:uppercase;color:var(--text-light-color)}
    .label-group{display:flex;justify-content:space-between;align-items:center}
    .label-group small{font-size:11px;font-weight:normal;text-transform:none}
    input,select{width:100%;padding:10px;background:var(--bg-color);border:1px solid var(--border-color);border-radius:4px;color:var(--text-color)}
    input:focus{border-color:var(--primary-color);outline:none;box-shadow:0 0 0 2px color-mix(in srgb, var(--primary-color) 20%, transparent)}
    .coord-group{display:flex;gap:10px;align-items:center}
    .input-group{display:flex;gap:10px;align-items:center}
    .input-group input{flex-grow:1}
    .input-group button{width:auto;padding:8px;font-size:16px}

    button{display:inline-flex;align-items:center;justify-content:center;gap:8px;padding:12px 18px;background:var(--primary-color);color:#fff;border:none;border-radius:5px;cursor:pointer;font-size:16px;font-weight:bold;transition:background-color .2s,transform .1s;width:100%}
    button:hover{background:var(--primary-hover-color)}
    button:active{transform:scale(.98)}
    .secondary-button{background:#6c757d}
    .secondary-button:hover{background:#5a6268}

    #verify-container{text-align:center}
    #verify-idle,#verify-loading,#verify-result{display:none}
    #verify-idle.active,#verify-loading.active,#verify-result.active{display:block}
    .verification-icon{font-size:60px;margin-bottom:20px}
    .result-card{padding:20px;border-radius:8px;margin-top:20px;text-align:left}
    .result-card h4{margin-top:0}
    .result-card.high{border:1px solid var(--success-color);background:rgba(25,135,84,.1)}
    .result-card.medium{border:1px solid var(--warning-color);background:rgba(255,193,7,.1)}
    .result-card.low{border:1px solid var(--danger-color);background:rgba(220,53,69,.1)}
    .verification-breakdown{list-style:none;padding:0}
    .verification-breakdown li{display:flex;align-items:center;gap:10px;margin-bottom:8px}
    .verification-breakdown .icon{font-size:20px}
    .verification-breakdown .icon.ok{color:var(--success-color)}
    .verification-breakdown .icon.fail{color:var(--danger-color)}
    #quick-scan-info{border:1px dashed var(--primary-color);padding:15px;margin-bottom:20px;border-radius:5px;text-align:left}
    #quick-scan-info p{margin:5px 0}

    #diagnostics{background:var(--bg-color);padding:15px;border-radius:4px;text-align:left;white-space:pre-wrap;word-wrap:break-word;font-family:monospace;font-size:12px;border:1px solid var(--border-color);max-height:300px;overflow-y:auto}

    hr{border:none;border-top:1px solid var(--border-color);margin:20px 0}

    #progress-modal,#error-modal{display:none;position:fixed;z-index:1000;left:0;top:0;width:100%;height:100%;background:rgba(0,0,0,.5);justify-content:center;align-items:center}
    .modal-content{background:var(--fg-color);padding:30px;border-radius:8px;text-align:center;width:90%;max-width:450px}
    #progress-bar{width:100%;height:10px;background:var(--border-color);border-radius:5px;overflow:hidden;margin-top:15px}
    #progress-bar-inner{width:0%;height:100%;background:var(--primary-color);transition:width .3s}
    #error-details{max-height:200px;overflow-y:auto;background:var(--bg-color);border:1px solid var(--border-color);padding:10px;margin-top:15px;text-align:left;font-family:monospace;font-size:12px}

    @media (max-width:900px){
      body{overflow:auto}
      .main-container{flex-direction:column;height:auto}
      .sidebar{width:100%;min-width:unset;border-right:none;border-bottom:1px solid var(--border-color)}
      .preview-area{padding:15px}
      .preview-frame{padding:10px}
      .header h1{font-size:18px}
      .logo svg{width:24px;height:24px}
    }
  </style>
</head>
<body>
<header class="header">
  <div class="logo">
    <svg viewBox="0 0 24 24" aria-hidden="true"><path d="M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2M11,16.5L6.5,12L7.91,10.59L11,13.67L16.09,8.59L17.5,10L11,16.5Z"></path></svg>
    <h1>CarbonAra</h1>
  </div>
  <div class="controls">
    <button id="theme-toggle" title="Växla mörkt/ljust läge" aria-label="Toggle theme">🌙</button>
  </div>
</header>

<main class="main-container">
  <aside class="sidebar">
    <div class="tabs">
      <button class="tab-button active" onclick="showTab('generate')">Generate</button>
      <button class="tab-button" onclick="showTab('verify')">Verify</button>
    </div>

    <div id="pane-generate" class="tab-content active">
      <details open>
        <summary><strong>1. Setup & Branding</strong></summary>
        <div class="details-content">
          <div class="form-group">
            <div class="label-group">
              <label for="image-upload">Background Image</label>
              <small id="bg-image-status"></small>
            </div>
            <input type="file" id="image-upload" accept="image/png, image/jpeg"/>
          </div>
          <div class="form-group">
            <label for="logo-upload">Branding Logo (Optional)</label>
            <input type="file" id="logo-upload" accept="image/png, image/jpeg"/>
          </div>
        </div>
      </details>

      <details open>
        <summary><strong>2. Certificate Data</strong></summary>
        <div class="details-content">
          <div class="form-group"><label for="input-name">Name</label><input type="text" id="input-name" value="John Doe"/></div>
          <div class="form-group"><label for="input-amount">Amount</label><input type="text" id="input-amount" value="100"/></div>
          <div class="form-group"><label for="input-date">Date</label><input type="date" id="input-date"/></div>
          <div class="form-group"><label for="input-type">Type</label><input type="text" id="input-type" value="Carbon Credit"/></div>
          <div class="form-group">
            <label for="input-serial">Serial Number</label>
            <div class="input-group">
              <input type="text" id="input-serial" readonly title="Unikt serienummer för spårbarhet"/>
              <button id="btn-generate-serial" title="Generera Nytt Serienummer" type="button">🔄</button>
            </div>
          </div>
        </div>
      </details>

      <details>
        <summary><strong>3. Layout & Style</strong></summary>
        <div class="details-content">
          <div class="form-group"><label for="input-fontsize-name">Name Font Size (px)</label><input type="number" id="input-fontsize-name" min="1"/></div>
          <div class="form-group">
            <label>Name Position (X, Y)</label>
            <div class="coord-group">
              <input type="number" id="input-x-name" step="0.0001"/>
              <input type="number" id="input-y-name" step="0.0001"/>
              <button onclick="centerElement('name')" type="button" title="Centrera namnet horisontellt">🎯</button>
            </div>
          </div>
          <hr/>
          <div class="form-group"><label for="input-fontsize-other">Data Font Size (px)</label><input type="number" id="input-fontsize-other" min="1"/></div>
          <div class="form-group">
            <label>Amount Position (X, Y)</label>
            <div class="coord-group">
              <input type="number" id="input-x-amount" step="0.0001"/>
              <input type="number" id="input-y-amount" step="0.0001"/>
              <button onclick="centerElement('amount')" type="button" title="Centrera horisontellt">🎯</button>
            </div>
          </div>
          <div class="form-group">
            <label>Date Position (X, Y)</label>
            <div class="coord-group">
              <input type="number" id="input-x-date" step="0.0001"/>
              <input type="number" id="input-y-date" step="0.0001"/>
              <button onclick="centerElement('date')" type="button" title="Centrera horisontellt">🎯</button>
            </div>
          </div>
          <div class="form-group">
            <label>Type Position (X, Y)</label>
            <div class="coord-group">
              <input type="number" id="input-x-type" step="0.0001"/>
              <input type="number" id="input-y-type" step="0.0001"/>
              <button onclick="centerElement('type')" type="button" title="Centrera horisontellt">🎯</button>
            </div>
          </div>
          <button id="btn-align-x" class="secondary-button" type="button" style="margin-bottom:1rem;">Align X for Amount &amp; Type</button>
          <hr/>
          <div class="form-group"><label for="input-fontsize-serial">Serial Nr. Font Size (px)</label><input type="number" id="input-fontsize-serial" min="1"/></div>
          <div class="form-group">
            <label>Serial Nr. Position (X, Y)</label>
            <div class="coord-group">
              <input type="number" id="input-x-serial" step="0.0001"/>
              <input type="number" id="input-y-serial" step="0.0001"/>
              <button onclick="centerElement('serial')" type="button" title="Centrera horisontellt">🎯</button>
            </div>
          </div>
          <hr/>
          <div class="form-group">
            <label>Logo Position &amp; Size (X, Y, Width)</label>
            <div class="coord-group">
              <input type="number" id="input-x-logo"/>
              <input type="number" id="input-y-logo"/>
              <input type="number" id="input-w-logo"/>
            </div>
          </div>
          <div class="input-group" style="margin-top:10px">
            <button id="btn-reset-all" class="secondary-button" type="button">Reset All Positions</button>
          </div>
        </div>
      </details>

      <details>
        <summary><strong>4. Export Options</strong></summary>
        <div class="details-content">
          <div class="form-group">
            <label for="input-dpi">DPI</label>
            <select id="input-dpi">
              <option value="150">150</option>
              <option value="300" selected>300</option>
            </select>
          </div>
          <div class="form-group">
            <label for="qr-mode">QR Code</label>
            <select id="qr-mode">
              <option value="with_qr">With QR Code</option>
              <option value="no_qr">No QR Code</option>
            </select>
          </div>
          <div id="qr-controls">
            <div class="form-group">
              <label>QR Position (X, Y)</label>
              <div class="coord-group">
                <input type="number" id="input-x-qr"/>
                <input type="number" id="input-y-qr"/>
              </div>
            </div>
            <div class="form-group">
              <label>QR Transparency</label>
              <input type="range" id="input-alpha-qr" min="0" max="1" step="0.05"/>
            </div>
            <button id="btn-reset-qr" class="secondary-button" type="button">Reset QR Position</button>
          </div>
          <hr/>
          <button id="btn-export-pdf" type="button">🔒 Generate Single PDF</button>
        </div>
      </details>
    </div>

    <div id="pane-verify" class="tab-content">
      <div id="verify-container">
        <div id="verify-idle" class="active">
          <div id="quick-scan-info" style="display:none;"></div>
          <div class="verification-icon" aria-hidden="true">🛡️</div>
          <h3>Secure Verification</h3>
          <p id="verify-prompt">Upload a CarbonAra PDF to verify its authenticity.</p>
          <input type="file" id="file-upload-verify" accept=".pdf" style="display:none;"/>
          <button type="button" onclick="document.getElementById('file-upload-verify').click();">Select PDF to Verify</button>
        </div>
        <div id="verify-loading">
          <div class="verification-icon" aria-hidden="true">⏳</div>
          <h3>Analyzing Certificate...</h3>
          <p>Extracting cryptographic signatures and metadata. Please wait.</p>
        </div>
        <div id="verify-result">
          <div id="auth-animation"></div>
          <h3 id="auth-prob"></h3>
          <div id="result-card-details" class="result-card"></div>
        </div>
      </div>
      <hr/>
      <details>
        <summary><strong>Expert Diagnostics</strong></summary>
        <div class="details-content">
          <div id="diagnostics">No data available.</div>
          <button id="copy-diag-report" class="secondary-button" style="margin-top:10px;" type="button">Copy Report</button>
        </div>
      </details>
    </div>
  </aside>

  <section class="preview-area" id="preview-area">
    <div class="preview-frame" id="preview-frame">
      <canvas id="previewCanvas" aria-label="Certificate preview"></canvas>
      <div class="preview-controls">
        <div id="canvas-dimensions">...</div>
        <div class="zoom-controls">
          <button id="zoom-out" title="Zoom Out" type="button" aria-label="Zoom out">-</button>
          <span id="zoom-level">100%</span>
          <button id="zoom-in" title="Zoom In" type="button" aria-label="Zoom in">+</button>
        </div>
      </div>
    </div>
  </section>
</main>

<div id="progress-modal" role="dialog" aria-modal="true" aria-labelledby="progress-title">
  <div class="modal-content">
    <h3 id="progress-title">Generating PDF...</h3>
    <p id="progress-status">Initializing secure processes...</p>
    <div id="progress-bar"><div id="progress-bar-inner"></div></div>
  </div>
</div>

<div id="error-modal" role="dialog" aria-modal="true" aria-labelledby="error-title">
  <div class="modal-content">
    <h3 id="error-title">An Error Occurred</h3>
    <p id="error-message"></p>
    <pre id="error-details"></pre>
    <button id="error-close-btn" type="button">Close</button>
  </div>
</div>

<script>
/* ---------- Utility helpers ---------- */
const safeJsonParse = (s)=>{ try{return JSON.parse(s)}catch{return null} };
const delay = (ms)=>new Promise(r=>setTimeout(r,ms));
const debounce=(fn,ms)=>{ let t; return (...a)=>{ clearTimeout(t); t=setTimeout(()=>fn(...a),ms); }; };

function dataURLtoUint8Array(dataURL){
  const base64 = dataURL.split(',')[1] || '';
  const binStr = atob(base64);
  const out = new Uint8Array(binStr.length);
  for(let i=0;i<binStr.length;i++) out[i]=binStr.charCodeAt(i);
  return out;
}
function u8ToBase64(u8){
  let bin=''; for(let i=0;i<u8.length;i++) bin+=String.fromCharCode(u8[i]);
  return btoa(bin);
}
function base64ToU8(b64){
  const bin=atob(b64); const u8=new Uint8Array(bin.length);
  for(let i=0;i<bin.length;i++) u8[i]=bin.charCodeAt(i);
  return u8;
}
async function sha256(bufLike){
  const buf = bufLike instanceof ArrayBuffer ? bufLike : (bufLike?.buffer || bufLike);
  const h=await crypto.subtle.digest('SHA-256', buf);
  return Array.from(new Uint8Array(h)).map(b=>b.toString(16).padStart(2,'0')).join('');
}
async function hashRGBFromImageDataDataBuffer(rgbaUint8){
  const rgb = new Uint8Array(Math.floor(rgbaUint8.length/4)*3);
  for(let src=0,dst=0; src<rgbaUint8.length; src+=4){
    rgb[dst++] = rgbaUint8[src];
    rgb[dst++] = rgbaUint8[src+1];
    rgb[dst++] = rgbaUint8[src+2];
  }
  return sha256(rgb.buffer);
}

/* ---------- Global state ---------- */
document.addEventListener('DOMContentLoaded', () => {
  const canvas = document.getElementById('previewCanvas');
  const ctx = canvas.getContext('2d',{ willReadFrequently:true });
  const bgImage = new Image();
  const logoImage = new Image();
  let qrImage = new Image();

  let bgImageLoaded=false, logoImageLoaded=false, zoomLevel=1, isRendering=false;

  const inputs = {
    name: document.getElementById('input-name'),
    amount: document.getElementById('input-amount'),
    date: document.getElementById('input-date'),
    type: document.getElementById('input-type'),
    serial: document.getElementById('input-serial'),
    dpi: document.getElementById('input-dpi'),
    fontSizeName: document.getElementById('input-fontsize-name'),
    fontSizeOther: document.getElementById('input-fontsize-other'),
    fontSizeSerial: document.getElementById('input-fontsize-serial'),
    xName: document.getElementById('input-x-name'), yName: document.getElementById('input-y-name'),
    xAmount: document.getElementById('input-x-amount'), yAmount: document.getElementById('input-y-amount'),
    xDate: document.getElementById('input-x-date'), yDate: document.getElementById('input-y-date'),
    xType: document.getElementById('input-x-type'), yType: document.getElementById('input-y-type'),
    xSerial: document.getElementById('input-x-serial'), ySerial: document.getElementById('input-y-serial'),
    xLogo: document.getElementById('input-x-logo'), yLogo: document.getElementById('input-y-logo'), wLogo: document.getElementById('input-w-logo'),
    qrMode: document.getElementById('qr-mode'), xQr: document.getElementById('input-x-qr'),
    yQr: document.getElementById('input-y-qr'), alphaQr: document.getElementById('input-alpha-qr'),
  };

  let textElements={}, logoElement={}, qrCodeElement={};

  /* ---------- Init ---------- */
  async function init(){
    inputs.date.valueAsDate = new Date();
    generateNewSerial();
    addEventListeners();
    await document.fonts.ready;

    // warm draw
    const tmp = inputs.name.value; inputs.name.value='Rendering…'; requestRedraw(); await delay(60); inputs.name.value=tmp;

    // background
    bgImage.crossOrigin='anonymous';
    bgImage.onload=()=>{ bgImageLoaded=true; id('bg-image-status').textContent='✅ image.png loaded'; setupCanvas(bgImage.naturalWidth,bgImage.naturalHeight); };
    bgImage.onerror=()=>{ id('bg-image-status').textContent='⚠️ No image.png'; setupCanvas(2480,3508); };
    bgImage.src='image.png';

    handleUrlParams();
  }

  function setupCanvas(w,h){
    canvas.width = Number.isFinite(w) && w>0 ? Math.round(w):2480;
    canvas.height= Number.isFinite(h) && h>0 ? Math.round(h):3508;
    id('canvas-dimensions').textContent = `${canvas.width} x ${canvas.height} px`;
    resetAllPositions();
    fitCanvasToView();
    requestRedraw();
  }

  function id(x){ return document.getElementById(x); }

  window.showTab=(tabName)=>{
    document.querySelectorAll('.tab-content, .tab-button').forEach(el=>el.classList.remove('active'));
    id(`pane-${tabName}`).classList.add('active');
    document.querySelector(`.tab-button[onclick="showTab('${tabName}')"]`).classList.add('active');
  };

  id('theme-toggle').addEventListener('click',()=>{
    const t=document.documentElement.getAttribute('data-theme')==='dark'?'light':'dark';
    document.documentElement.setAttribute('data-theme',t);
    id('theme-toggle').textContent= t==='dark'?'☀️':'🌙';
    requestRedraw();
  });

  /* ---------- Events ---------- */
  function addEventListeners(){
    const debounced = debounce(requestRedraw,30);
    Object.values(inputs).forEach(el=>el.addEventListener('input',debounced));

    id('image-upload').addEventListener('change', handleImageUpload);
    id('logo-upload').addEventListener('change', handleLogoUpload);
    id('btn-reset-all').addEventListener('click', resetAllPositions);
    id('btn-reset-qr').addEventListener('click', resetQrPosition);
    id('btn-export-pdf').addEventListener('click', exportPdf);
    id('btn-generate-serial').addEventListener('click', generateNewSerial);
    id('btn-align-x').addEventListener('click', alignXValues);
    id('file-upload-verify').addEventListener('change', handleVerifyUpload);
    id('zoom-in').addEventListener('click', ()=>updateZoom(0.2));
    id('zoom-out').addEventListener('click', ()=>updateZoom(-0.2));
    id('error-close-btn').addEventListener('click',()=> id('error-modal').style.display='none');

    id('copy-diag-report').addEventListener('click', async ()=>{
      const txt=id('diagnostics').textContent||'';
      try{ await navigator.clipboard.writeText(txt); alert('Diagnostics copied.'); }
      catch{ const ta=document.createElement('textarea'); ta.value=txt; document.body.appendChild(ta); ta.select(); document.execCommand('copy'); ta.remove(); alert('Diagnostics copied.'); }
    });

    window.addEventListener('resize', fitCanvasToView);

    // drag on canvas
    let dragging=false, selectedKey=null, offset={x:0,y:0};
    canvas.addEventListener('mousedown', e=>{
      const pos=getCanvasMousePos(e);
      const elements={...textElements, logo:logoElement, qr:qrCodeElement};
      const keys=Object.keys(elements).reverse();
      for(const key of keys){
        const el=elements[key]; if(!el||!el.draggable) continue;
        ctx.font=`${el.fontSize||12}px '${el.font||'Montserrat'}'`;
        const w= key==='logo'? el.width : (key==='qr'? el.size : ctx.measureText(el.text||'').width);
        const h= key==='logo'? el.height: (key==='qr'? el.size : (el.fontSize||12));
        const x0=(key==='logo'||key==='qr')? el.x : el.x - w/2;
        const y0=(key==='logo'||key==='qr')? el.y : el.y;
        if(pos.x>=x0 && pos.x<=x0+w && pos.y>=y0 && pos.y<=y0+h){
          dragging=true; selectedKey=key; offset={x:pos.x-el.x, y:pos.y-el.y}; canvas.style.cursor='grabbing'; return;
        }
      }
    });
    window.addEventListener('mousemove', e=>{
      if(!dragging||!selectedKey) return;
      const pos=getCanvasMousePos(e);
      const el = selectedKey==='logo'? logoElement : (selectedKey==='qr'? qrCodeElement : textElements[selectedKey]);
      el.x = Math.max(0, Math.min(canvas.width  - (selectedKey==='logo'? el.width : 0), pos.x - offset.x));
      el.y = Math.max(0, Math.min(canvas.height - (selectedKey==='logo'? el.height: 0), pos.y - offset.y));
      updateCoordsFromCanvas(selectedKey);
      requestRedraw();
    });
    window.addEventListener('mouseup',()=>{ dragging=false; selectedKey=null; canvas.style.cursor='grab'; });
  }

  /* ---------- Canvas / draw ---------- */
  function requestRedraw(){
    if(isRendering) return;
    isRendering=true;
    requestAnimationFrame(()=>{
      try{ updateElementsFromInputs(); drawCanvas(); }
      finally{ isRendering=false; }
    });
  }

  function drawCanvas(){
    ctx.textBaseline='top';
    ctx.clearRect(0,0,canvas.width,canvas.height);
    if(bgImageLoaded) ctx.drawImage(bgImage,0,0,canvas.width,canvas.height);
    else { ctx.fillStyle= (document.documentElement.getAttribute('data-theme')==='dark')?'#1e1e1e':'#ffffff'; ctx.fillRect(0,0,canvas.width,canvas.height); }

    if(logoImageLoaded && logoElement.width>0) ctx.drawImage(logoImage, logoElement.x, logoElement.y, logoElement.width, logoElement.height);

    const color = (document.documentElement.getAttribute('data-theme')==='dark')?'#e0e0e0':'#212529';
    Object.values(textElements).forEach(el=>{
      const size=Number.isFinite(el.fontSize)? el.fontSize:12;
      ctx.font = `${size}px '${el.font||'Montserrat'}'`;
      const w=ctx.measureText(el.text||'').width;
      ctx.fillStyle=color;
      ctx.fillText(el.text||'', el.x - w/2, el.y);
    });

    if(inputs.qrMode.value==='with_qr' && qrImage.src){
      ctx.globalAlpha = qrCodeElement.alpha;
      ctx.drawImage(qrImage, qrCodeElement.x, qrCodeElement.y, qrCodeElement.size, qrCodeElement.size);
      ctx.globalAlpha = 1.0;
    }
  }

  function updateElementsFromInputs(){
    const num=v=>{ const n=parseFloat(v); return Number.isFinite(n)? n:0; };
    const fsOther=num(inputs.fontSizeOther.value);
    textElements={
      name:{text:(inputs.name.value||'').normalize('NFC'), x:num(inputs.xName.value), y:num(inputs.yName.value), font:'Great Vibes', fontSize:num(inputs.fontSizeName.value), draggable:true},
      amount:{text:inputs.amount.value||'', x:num(inputs.xAmount.value), y:num(inputs.yAmount.value), font:'Montserrat', fontSize:fsOther, draggable:true},
      date:{text:inputs.date.value||'', x:num(inputs.xDate.value), y:num(inputs.yDate.value), font:'Montserrat', fontSize:fsOther, draggable:true},
      type:{text:(inputs.type.value||'').normalize('NFC'), x:num(inputs.xType.value), y:num(inputs.yType.value), font:'Montserrat', fontSize:fsOther, draggable:true},
      serial:{text:inputs.serial.value||'', x:num(inputs.xSerial.value), y:num(inputs.ySerial.value), font:'Montserrat', fontSize:num(inputs.fontSizeSerial.value), draggable:true}
    };
    if(logoImageLoaded){
      const w=num(inputs.wLogo.value);
      const h = logoImage.height ? (logoImage.height*(w/Math.max(1,logoImage.width))) : 0;
      logoElement={x:num(inputs.xLogo.value), y:num(inputs.yLogo.value), width:w, height:h, draggable:true};
    }else{
      logoElement={x:0,y:0,width:0,height:0,draggable:false};
    }
    qrCodeElement={ x:num(inputs.xQr.value), y:num(inputs.yQr.value),
      alpha:(()=>{ const a=parseFloat(inputs.alphaQr.value); return Number.isFinite(a)? Math.max(0,Math.min(1,a)) : 0.8; })(),
      size:150, draggable: inputs.qrMode.value==='with_qr'
    };
    generateQrImage();
  }

  function resetAllPositions(){
    const d={
      fontSizeName:100, xName:705.6404, yName:1005.7899,
      fontSizeOther:33, xAmount:359.1387, yAmount:1531.1968,
      xDate:1068.8586, yDate:1527.7868,
      xType:359.1387, yType:1676.0735,
      fontSizeSerial:22, xSerial:516.0143, ySerial:1943.9245,
      xLogo:50, yLogo:50, wLogo:200
    };
    Object.entries(d).forEach(([k,v])=>{ if(inputs[k]) inputs[k].value=v; });
    resetQrPosition();
    requestRedraw();
  }
  function resetQrPosition(){
    const margin=50, size=150;
    inputs.xQr.value = String(Math.max(0,canvas.width - size - margin));
    inputs.yQr.value = String(Math.max(0,canvas.height- size - margin));
    inputs.alphaQr.value= String(0.8);
    requestRedraw();
  }
  function getCanvasMousePos(e){
    const r=canvas.getBoundingClientRect();
    return { x:(e.clientX-r.left)*(canvas.width/r.width), y:(e.clientY-r.top)*(canvas.height/r.height) };
  }
  function updateCoordsFromCanvas(key){
    const el = key==='logo'? logoElement : (key==='qr'? qrCodeElement : textElements[key]);
    const set=(id,val)=>{ const n=id&&document.getElementById(`input-${id}`); if(n) n.value = typeof val==='number'? val.toFixed(4):val; };
    set(`x-${key.toLowerCase()}`, el.x); set(`y-${key.toLowerCase()}`, el.y);
  }

  function handleImageUpload(ev){
    const f=ev.target.files?.[0]; if(!f) return;
    if(!/^image\/(png|jpeg)$/i.test(f.type)){ showError('Invalid Image','Please upload PNG or JPEG.'); return; }
    const r=new FileReader();
    r.onload = e=>{
      bgImage.onload=()=>{ bgImageLoaded=true; id('bg-image-status').textContent=`✅ ${f.name} loaded`; setupCanvas(bgImage.naturalWidth||canvas.width, bgImage.naturalHeight||canvas.height); };
      bgImage.onerror=()=>showError('Image Load Error','Failed to load selected background.');
      bgImage.src=e.target.result;
    };
    r.readAsDataURL(f);
  }
  function handleLogoUpload(ev){
    const f=ev.target.files?.[0]; if(!f) return;
    if(!/^image\/(png|jpeg)$/i.test(f.type)){ showError('Invalid Logo','Please upload PNG or JPEG.'); return; }
    const r=new FileReader();
    r.onload = e=>{
      logoImage.onload=()=>{ logoImageLoaded=true; requestRedraw(); };
      logoImage.onerror=()=>showError('Logo Load Error','Failed to load selected logo.');
      logoImage.src=e.target.result;
    };
    r.readAsDataURL(f);
  }

  function generateNewSerial(){
    inputs.serial.value = `SN-${Date.now()}-${Math.random().toString(36).slice(2,11).toUpperCase()}`;
    requestRedraw();
  }
  window.centerElement=(key)=>{
    const t=`x${key.charAt(0).toUpperCase()+key.slice(1)}`;
    if(inputs[t]){ inputs[t].value=(canvas.width/2).toFixed(4); requestRedraw(); }
  };
  function alignXValues(){ inputs.xType.value = inputs.xAmount.value; requestRedraw(); }
  function fitCanvasToView(){
    const area=id('preview-area'), frame=id('preview-frame');
    const s=Math.min((area.clientHeight-60)/Math.max(1,frame.offsetHeight),(area.clientWidth-60)/Math.max(1,frame.offsetWidth),1);
    zoomLevel=s; updateZoom(0);
  }
  function updateZoom(d){
    zoomLevel=Math.max(.1,Math.min(3,zoomLevel+d));
    id('preview-frame').style.transform=`scale(${zoomLevel})`;
    id('zoom-level').textContent=`${Math.round(zoomLevel*100)}%`;
  }

  function handleUrlParams(){
    const p=new URLSearchParams(location.search);
    const encoded=p.get('verify');
    if(!encoded) return;
    try{
      const dec=atob(encoded.replace(/-/g,'+').replace(/_/g,'/'));
      const qrData=safeJsonParse(dec)||{};
      showTab('verify');
      const q=id('quick-scan-info'); q.style.display='block';
      q.innerHTML=`<h4>Quick Scan Information</h4>
        <p><strong>Serial:</strong> ${qrData.s||'N/A'}</p>
        <p><strong>Name:</strong> ${qrData.n||'N/A'}</p>
        <p><strong>Amount:</strong> ${qrData.a||'N/A'}</p>
        <p><strong>Date:</strong> ${qrData.d||'N/A'}</p>
        <p><strong>Type:</strong> ${qrData.t||'N/A'}</p>
        <p><em>Upload the corresponding PDF for full cryptographic verification.</em></p>`;
      id('verify-prompt').textContent=`Ready to verify serial: ${qrData.s||'N/A'}.`;
    }catch(e){
      console.error('QR param decode failed',e);
      showError('Invalid QR Code Link','Verification link is corrupted or invalid.');
    }
  }

  function generateQrImage(){
    try{
      if(inputs.qrMode.value!=='with_qr'){ qrImage.src=''; return; }
      const qrData={ s:inputs.serial.value, n:inputs.name.value, a:inputs.amount.value, d:inputs.date.value, t:inputs.type.value };
      const encoded=btoa(JSON.stringify(qrData)).replace(/\+/g,'-').replace(/\//g,'_').replace(/=+$/,'');
      const value=`https://nomsams.github.io/carbonara/?verify=${encoded}`;
      const qri=new QRious({ value, size:512 });
      qrImage=new Image(); qrImage.src=qri.toDataURL();
    }catch(e){ console.warn('QR gen failed',e); qrImage.src=''; }
  }

  /* ---------- Crypto + canonical ---------- */
  const masterKeySalt="CarbonCertSaltV1", pbkdf2Iterations=100000;
  async function reconstructMasterKey(){
    const fragments=['fragA','fragB','fragC','fragD'];
    const concatenated=fragments.join('')+'a-very-secret-pepper';
    const base=await crypto.subtle.importKey('raw', new TextEncoder().encode(concatenated), {name:'PBKDF2'}, false, ['deriveKey']);
    return await crypto.subtle.deriveKey(
      {name:'PBKDF2',salt:new TextEncoder().encode(masterKeySalt),iterations:pbkdf2Iterations,hash:'SHA-256'},
      base,{name:'HMAC',hash:'SHA-256',length:256},true,['sign','verify']
    );
  }
  function getCanonicalString(p){
    return [
      `v:${p.v}`,`serial:${p.serial}`,`name:${p.name}`,`amount:${p.amount}`,`date:${p.date}`,`type:${p.type}`,
      `imageHashOriginal:${p.imageHashOriginal}`,`imageHashWatermarked:${p.imageHashWatermarked}`,`imageHashRGB:${p.imageHashRGB}`,`imageHashAttachment:${p.imageHashAttachment||''}`,
      `posName:${p.posName.x},${p.posName.y}`,`posAmount:${p.posAmount.x},${p.posAmount.y}`,
      `posDate:${p.posDate.x},${p.posDate.y}`,`posType:${p.posType.x},${p.posType.y}`,
      `posSerial:${p.posSerial.x},${p.posSerial.y}`,`posLogo:${p.posLogo.x},${p.posLogo.y},${p.posLogo.w}`,
      `fontName:${p.fontName}`,`fontOther:${p.fontOther}`,`fontSerial:${p.fontSerial}`,
      `qrMode:${p.qrMode}`,`qrPos:${p.qrPos.x},${p.qrPos.y}`,`qrAlpha:${p.qrAlpha}`,
      `canvas:${p.canvas}`,`app:${p.app}`
    ].join('|');
  }
  async function generateTag(canon){
    const key=await reconstructMasterKey();
    const data=await crypto.subtle.digest('SHA-256', new TextEncoder().encode(canon));
    const sig=await crypto.subtle.sign('HMAC', key, data);
    return btoa(String.fromCharCode(...new Uint8Array(sig)));
  }

  /* ---------- LSB stego ---------- */
  function embedDataLSB(ctx2d, str){
    const term="::END::";
    const bits=Array.from(str+term).map(c=>c.charCodeAt(0).toString(2).padStart(8,'0')).join('');
    const img=ctx2d.getImageData(0,0,ctx2d.canvas.width,ctx2d.canvas.height);
    const data=img.data;
    const capacity=Math.floor(data.length/4);
    if(bits.length>capacity) throw new Error(`Watermark too large. Need ${bits.length} bits, capacity ${capacity}.`);
    for(let i=0;i<bits.length;i++){
      const idx=i*4+2; data[idx]= (data[idx]&0xFE) | (bits[i]==='1'?1:0);
    }
    ctx2d.putImageData(img,0,0);
  }
  function extractDataLSB(ctx2d){
    const img=ctx2d.getImageData(0,0,ctx2d.canvas.width,ctx2d.canvas.height);
    const d=img.data; let bits='';
    for(let i=0;i<d.length;i+=4) bits += (d[i+2]&1);
    const bytes=bits.match(/.{1,8}/g)||[]; let s='';
    for(const b of bytes){ if(b.length<8) continue; s+=String.fromCharCode(parseInt(b,2)); if(s.endsWith('::END::')) return s.slice(0,-7); }
    return null;
  }

  /* ---------- Export PDF (robust metadata; fixes setKeywords error) ---------- */
  async function exportPdf(){
    const modal=id('progress-modal'), status=id('progress-status'), bar=id('progress-bar-inner');
    modal.style.display='flex';
    const step=(msg,p)=>{ status.textContent=msg; bar.style.width=p; };

    try{
      step('Step 1/8: Preparing canvas…','8%'); await delay(10);

      const c=document.createElement('canvas'); c.width=canvas.width; c.height=canvas.height;
      const cx=c.getContext('2d',{ willReadFrequently:true });
      updateElementsFromInputs();

      // draw
      cx.textBaseline='top';
      if(bgImageLoaded) cx.drawImage(bgImage,0,0,c.width,c.height); else { cx.fillStyle='#FFF'; cx.fillRect(0,0,c.width,c.height); }
      if(logoImageLoaded && logoElement.width>0) cx.drawImage(logoImage,logoElement.x,logoElement.y,logoElement.width,logoElement.height);
      Object.values(textElements).forEach(el=>{
        const size=Number.isFinite(el.fontSize)? el.fontSize:12;
        cx.font=`${size}px '${el.font||'Montserrat'}'`;
        const w=cx.measureText(el.text||'').width;
        cx.fillStyle='#000'; cx.fillText(el.text||'', el.x - w/2, el.y);
      });
      if(inputs.qrMode.value==='with_qr' && qrImage.src){ cx.globalAlpha=qrCodeElement.alpha; cx.drawImage(qrImage, qrCodeElement.x, qrCodeElement.y, qrCodeElement.size, qrCodeElement.size); cx.globalAlpha=1.0; }

      step('Step 2/8: Calculating image hashes…','22%');
      const origID = cx.getImageData(0,0,c.width,c.height);
      const imageHashOriginal = await sha256(origID.data.buffer);

      // Provisional tag -> embed -> recompute watermarked hashes
      const provisionalTag = await generateTag(getCanonicalString({
        v:1, serial:inputs.serial.value, name:(inputs.name.value||'').normalize('NFC'), amount:inputs.amount.value||'', date:inputs.date.value||'', type:(inputs.type.value||'').normalize('NFC'),
        imageHashOriginal, imageHashWatermarked:'0'.repeat(64), imageHashRGB:'0'.repeat(64), imageHashAttachment:'',
        posName:{x:Number(textElements.name.x).toFixed(4), y:Number(textElements.name.y).toFixed(4)},
        posAmount:{x:Number(textElements.amount.x).toFixed(4), y:Number(textElements.amount.y).toFixed(4)},
        posDate:{x:Number(textElements.date.x).toFixed(4), y:Number(textElements.date.y).toFixed(4)},
        posType:{x:Number(textElements.type.x).toFixed(4), y:Number(textElements.type.y).toFixed(4)},
        posSerial:{x:Number(textElements.serial.x).toFixed(4), y:Number(textElements.serial.y).toFixed(4)},
        posLogo:{x:Number(logoElement.x||0).toFixed(4), y:Number(logoElement.y||0).toFixed(4), w:Number(logoElement.width||0).toFixed(4)},
        fontName:`GreatVibes-${Number(textElements.name.fontSize||0)}px`,
        fontOther:`Montserrat-${Number(textElements.amount.fontSize||0)}px`,
        fontSerial:`Montserrat-${Number(textElements.serial.fontSize||0)}px`,
        qrMode:inputs.qrMode.value, qrPos:{x:Number(qrCodeElement.x||0).toFixed(4), y:Number(qrCodeElement.y||0).toFixed(4)}, qrAlpha:Number(qrCodeElement.alpha||0).toFixed(2),
        canvas:`${canvas.width}x${canvas.height}@${inputs.dpi.value}`, app:'CarbonCert-5.0.0'
      }));
      embedDataLSB(cx, provisionalTag);

      const wmID = cx.getImageData(0,0,c.width,c.height);
      const imageHashWatermarked = await sha256(wmID.data.buffer);
      const imageHashRGB = await hashRGBFromImageDataDataBuffer(wmID.data);

      step('Step 3/8: Serializing PNG (watermarked)…','34%');
      const pngURI = c.toDataURL('image/png');
      const pngBytes = dataURLtoUint8Array(pngURI);
      const imageHashAttachment = await sha256(pngBytes.buffer);

      const basePayload = {
        v:1, serial:inputs.serial.value,
        name:(inputs.name.value||'').normalize('NFC'),
        amount:inputs.amount.value||'',
        date:inputs.date.value||'',
        type:(inputs.type.value||'').normalize('NFC'),
        imageHashOriginal,
        imageHashWatermarked,
        imageHashRGB,
        imageHashAttachment,
        posName:{x:Number(textElements.name.x).toFixed(4), y:Number(textElements.name.y).toFixed(4)},
        posAmount:{x:Number(textElements.amount.x).toFixed(4), y:Number(textElements.amount.y).toFixed(4)},
        posDate:{x:Number(textElements.date.x).toFixed(4), y:Number(textElements.date.y).toFixed(4)},
        posType:{x:Number(textElements.type.x).toFixed(4), y:Number(textElements.type.y).toFixed(4)},
        posSerial:{x:Number(textElements.serial.x).toFixed(4), y:Number(textElements.serial.y).toFixed(4)},
        posLogo:{x:Number(logoElement.x||0).toFixed(4), y:Number(logoElement.y||0).toFixed(4), w:Number(logoElement.width||0).toFixed(4)},
        fontName:`GreatVibes-${Number(textElements.name.fontSize||0)}px`,
        fontOther:`Montserrat-${Number(textElements.amount.fontSize||0)}px`,
        fontSerial:`Montserrat-${Number(textElements.serial.fontSize||0)}px`,
        qrMode:inputs.qrMode.value,
        qrPos:{x:Number(qrCodeElement.x||0).toFixed(4), y:Number(qrCodeElement.y||0).toFixed(4)},
        qrAlpha:Number(qrCodeElement.alpha||0).toFixed(2),
        canvas:`${canvas.width}x${canvas.height}@${inputs.dpi.value}`,
        app:'CarbonCert-5.0.0'
      };
      const finalTag = await generateTag(getCanonicalString(basePayload));
      const payloadWithTag = { ...basePayload, tag_b64: finalTag };

      // Prepare compact, ASCII-safe metadata: "carboncert" + base64(JSON)
      const jsonBytes = new TextEncoder().encode(JSON.stringify(payloadWithTag));
      const jsonB64 = u8ToBase64(jsonBytes);
      const keywordsArray = ['carboncert', jsonB64]; // keep short tokens

      step('Step 4/8: Building PDF…','50%');
      const { PDFDocument } = window.PDFLib;
      const pdfDoc=await PDFDocument.create();
      const page=pdfDoc.addPage([canvas.width, canvas.height]);

      const pngImg=await pdfDoc.embedPng(pngBytes);
      page.drawImage(pngImg,{x:0,y:0,width:canvas.width,height:canvas.height});

      // Attach raster safely
      step('Step 5/8: Embedding raster as attachment…','62%');
      try{
        await pdfDoc.attach(pngBytes, `CarbonAra-${basePayload.serial}.png`, {
          mimeType:'image/png', description:'Original raster used to compose this document', createDate:new Date(), modificationDate:new Date()
        });
      }catch(e){
        console.warn('Attachment (PNG) skipped:', e);
      }

      // Attach JSON payload as well for rock-solid retrieval
      step('Step 6/8: Embedding payload JSON…','74%');
      try{
        await pdfDoc.attach(jsonBytes, `carboncert-${basePayload.serial}.json`, {
          mimeType:'application/json', description:'CarbonAra certificate payload (authenticity data)', createDate:new Date(), modificationDate:new Date()
        });
      }catch(e){ console.warn('Attachment (JSON) skipped:', e); }

      // Set metadata (robust: try setKeywords -> fallback to Subject)
      pdfDoc.setProducer('CarbonAra');
      pdfDoc.setCreator('CarbonAra:PNG@PDF');
      pdfDoc.setTitle(`CarbonAra ${basePayload.serial}`);

      step('Step 7/8: Writing metadata…','86%');
      let keywordsOk = false;
      try{
        // Some pdf-lib versions throw if the array contains non-ASCII or overly-long entries.
        // We pass two short ASCII tokens only.
        pdfDoc.setKeywords(keywordsArray);
        keywordsOk = true;
      }catch(eK){
        console.warn('setKeywords failed, falling back to Subject:', eK);
        try{
          pdfDoc.setSubject(`carboncert,${jsonB64}`); // compact, ASCII-safe
          keywordsOk = true;
        }catch(eS){
          console.warn('setSubject also failed; metadata will rely on attachments.', eS);
          // As a last resort, write compact info into Author (safe ASCII)
          try{ pdfDoc.setAuthor(`carboncert:${jsonB64}`); } catch(eA){ /* ignore */ }
        }
      }

      step('Step 8/8: Finalizing & downloading…','94%');
      const pdfBytes = await pdfDoc.save({ useObjectStreams:false });

      download(pdfBytes,`CarbonCert-${basePayload.serial}.pdf`,'application/pdf');
      id('progress-bar-inner').style.width='100%';
      setTimeout(()=> id('progress-modal').style.display='none',600);
    }catch(e){
      showError('PDF Generation Failed', e?.stack||e?.message||String(e));
      id('progress-modal').style.display='none';
    }
  }

  function download(data,filename,type){
    try{
      const blob=new Blob([data],{type});
      const url=URL.createObjectURL(blob);
      const a=document.createElement('a'); a.href=url; a.download=filename; document.body.appendChild(a); a.click();
      setTimeout(()=>{ URL.revokeObjectURL(url); a.remove(); },0);
    }catch(e){ showError('Download Error', e?.stack||String(e)); }
  }

  /* ---------- Verification (attachment/keywords/subject/author-aware) ---------- */
  async function handleVerifyUpload(ev){
    const file=ev.target.files?.[0]; if(!file) return;

    const vc=id('verify-container');
    vc.querySelector('#verify-idle').classList.remove('active');
    vc.querySelector('#verify-loading').classList.add('active');

    const diag=id('diagnostics'); diag.textContent='';
    const log=(m)=> diag.textContent += `[${new Date().toLocaleTimeString()}] ${m}\n`;

    try{
      log('Starting verification...');
      const { PDFDocument, PDFName, PDFDict, PDFRawStream, PDFStream } = window.PDFLib;
      const pdfBytes=await file.arrayBuffer();
      const pdfDoc=await PDFDocument.load(pdfBytes,{ ignoreEncryption:true });
      log('PDF document loaded successfully.');

      // --- Locate payload: Keywords -> Subject -> Author -> JSON attachment
      let payload = null;
      let location = 'none';

      // 1) Keywords path: expect ['carboncert', base64]
      try{
        let kws = pdfDoc.getKeywords?.() || null;
        if(Array.isArray(kws) && kws.length){
          const hasFlag = kws.find(k => typeof k==='string' && k.toLowerCase()==='carboncert');
          const b64 = kws.find(k => typeof k==='string' && k!==hasFlag && /^[A-Za-z0-9+/=]+$/.test(k) && k.length>20);
          if(hasFlag && b64){
            const bytes = base64ToU8(b64);
            const json = new TextDecoder().decode(bytes);
            const obj = safeJsonParse(json);
            if(obj) { payload=obj; location='keywords'; }
          }
        }
      }catch(_eK){ /* ignore */ }

      // 2) Subject fallback
      if(!payload){
        try{
          const subj = pdfDoc.getSubject?.();
          if(typeof subj==='string' && subj.startsWith('carboncert,')){
            const b64 = subj.slice('carboncert,'.length);
            const bytes = base64ToU8(b64);
            const json = new TextDecoder().decode(bytes);
            const obj = safeJsonParse(json);
            if(obj){ payload=obj; location='subject'; }
          }
        }catch(_eS){ /* ignore */ }
      }

      // 3) Author fallback (`carboncert:<b64>`)
      if(!payload){
        try{
          const author = pdfDoc.getAuthor?.();
          if(typeof author==='string' && author.startsWith('carboncert:')){
            const b64 = author.slice('carboncert:'.length);
            const bytes = base64ToU8(b64);
            const json = new TextDecoder().decode(bytes);
            const obj = safeJsonParse(json);
            if(obj){ payload=obj; location='author'; }
          }
        }catch(_eA){ /* ignore */ }
      }

      // 4) JSON attachment fallback
      if(!payload){
        try{
          const jsonAttach = await tryGetJsonAttachmentBytes(pdfDoc);
          if(jsonAttach){
            const json = new TextDecoder().decode(jsonAttach);
            const obj = safeJsonParse(json);
            if(obj){ payload=obj; location='attachment-json'; }
          }
        }catch(_eJ){ /* ignore */ }
      }

      if(!payload){
        throw new Error('No embedded CarbonAra payload found in Keywords/Subject/Author/Attachments.');
      }
      log(`Payload found via: ${location}.`);

      // --- Crypto check (authoritative)
      log('Rebuilding canonical string for signature verification…');
      const expected=await generateTag(getCanonicalString(payload));
      log(`Expected tag: ${expected.slice(0,16)}…`);
      const tagFromMeta=payload.tag_b64||'';
      log(`Metadata tag: ${tagFromMeta.slice(0,16)}…`);

      const result={ crypto:(tagFromMeta===expected)?'OK':'FAIL', water:'SKIPPED', hash:'SKIPPED', status:'LOW' };

      if(result.crypto==='OK'){
        // 0) Attachment-first: PNG or image for direct pixel/hash/LSB
        try{
          const attachment = await tryGetEmbeddedAttachmentBytes(pdfDoc);
          if(attachment && attachment.bytes){
            const h = await sha256(attachment.bytes.buffer);
            log(`Attachment hash: ${h.slice(0,16)}… vs payload attachment ${(payload.imageHashAttachment||'').slice(0,16)}…`);
            if(h === (payload.imageHashAttachment||'')) {
              result.hash='OK';
            }
            const attAnalysis = await analyzeImageBytes(attachment.bytes);
            if(attAnalysis){
              const { pixelsHashRGBA, pixelsHashRGB, extractedTag } = attAnalysis;
              if(result.hash!=='OK' && (pixelsHashRGBA===payload.imageHashWatermarked || pixelsHashRGB===payload.imageHashRGB)) result.hash='OK';
              if(extractedTag){ result.water = (extractedTag===tagFromMeta)?'OK':'FAIL'; }
            }
          } else {
            log('No embedded PNG/JPEG attachment found.');
          }
        }catch(e0){ log('Attachment-based verification failed: '+(e0?.message||String(e0))); }

        // A) pdf-lib XObject traversal (best-effort)
        if(result.hash!=='OK' || result.water!=='OK'){
          try{
            log('Attempting bitmap extraction (Strategy A: pdf-lib XObject traversal)…');
            const info = await extractImageLikeWithPdfLib(pdfDoc, { PDFName, PDFDict, PDFRawStream, PDFStream });
            if(info && info.kind==='png-dataurl'){
              log('Strategy A: Found PNG-like stream, decoding…');
              const { pixelsHashRGBA, pixelsHashRGB, extractedTag } = await hashAndExtractFromDataURL(info.dataURL);
              log(`A(PNG): RGBA calc ${pixelsHashRGBA.slice(0,16)}… vs payload RGBA ${payload.imageHashWatermarked.slice(0,16)}…`);
              log(`A(PNG): RGB  calc ${pixelsHashRGB.slice(0,16)}… vs payload RGB  ${payload.imageHashRGB.slice(0,16)}…`);
              if(result.hash!=='OK' && (pixelsHashRGBA===payload.imageHashWatermarked || pixelsHashRGB===payload.imageHashRGB)) result.hash='OK';
              if(extractedTag){ result.water = (extractedTag===tagFromMeta)?'OK':'FAIL'; }
            }else if(info && info.kind==='raw-pixels'){
              log('Strategy A: Found raw pixel stream; drawing to canvas…');
              const { pixelsHashRGBA, pixelsHashRGB, extractedTag } = await drawRawPixelsAndAnalyze(info);
              if(pixelsHashRGBA||pixelsHashRGB){
                log(`A(raw): RGBA calc ${pixelsHashRGBA?.slice(0,16)||'n/a'}… vs payload RGBA ${payload.imageHashWatermarked.slice(0,16)}…`);
                log(`A(raw): RGB  calc ${pixelsHashRGB?.slice(0,16)||'n/a'}… vs payload RGB  ${payload.imageHashRGB.slice(0,16)}…`);
              }
              if(result.hash!=='OK' && (pixelsHashRGBA===payload.imageHashWatermarked || pixelsHashRGB===payload.imageHashRGB)) result.hash='OK';
              if(extractedTag){ result.water = (extractedTag===tagFromMeta)?'OK':'FAIL'; }
            }else{
              log('Strategy A: No direct image stream retrievable.');
            }
          }catch(eA){ log('Strategy A failed: '+(eA?.message||String(eA))); }
        }
      }

      // Final status policy:
      if(result.crypto==='OK' && (result.water==='OK' || result.hash==='OK')) result.status='HIGH';
      else if(result.crypto==='OK') result.status='MEDIUM';
      else result.status='LOW';

      log(`Verification complete. Final status: ${result.status}`);
      displayVerificationResult(result, payload);
    }catch(e){
      diag.textContent += `CRITICAL ERROR: ${e?.message||String(e)}\n`;
      displayVerificationResult({ status:'LOW', water:'FAIL', crypto:'FAIL', hash:'FAIL', error:e?.message||String(e) });
    }finally{
      id('verify-loading').classList.remove('active');
    }
  }

  /* ---------- Attachment helpers ---------- */
  async function tryGetJsonAttachmentBytes(pdfDoc){
    const { PDFName, PDFDict, PDFRawStream, PDFStream } = window.PDFLib;
    // Filespec dictionaries first
    try{
      for(const [ref, obj] of pdfDoc.context.enumerateIndirectObjects()){
        if(obj && obj.dict && obj.dict.get){
          const type = obj.dict.get(PDFName.of('Type'));
          if(String(type)==='/Filespec'){
            const fname = obj.dict.get(PDFName.of('F'));
            const ufname= obj.dict.get(PDFName.of('UF'));
            const nameStr = (fname?String(fname):'') + (ufname?String(ufname):'');
            if(/carboncert-.*\.json$/i.test(nameStr)){
              const ef = obj.dict.get(PDFName.of('EF'));
              if(ef){
                const efDict = pdfDoc.context.lookup(ef, PDFDict);
                const keys = efDict.keys? efDict.keys(): [];
                for(const k of keys){
                  const streamRef = efDict.get ? efDict.get(k) : null;
                  if(!streamRef) continue;
                  const stream = pdfDoc.context.lookup(streamRef);
                  if(stream && (stream instanceof PDFRawStream || stream instanceof PDFStream)){
                    const contents = stream.getContents ? stream.getContents() : stream.contents;
                    if(contents) return (contents instanceof Uint8Array)? contents : new Uint8Array(contents);
                  }
                }
              }
            }
          }
        }
      }
    }catch(_e){ /* ignore */ }

    // Fallback: any EmbeddedFile with JSON-ish name
    try{
      for(const [ref,obj] of pdfDoc.context.enumerateIndirectObjects()){
        if(obj && (obj instanceof PDFRawStream || obj instanceof PDFStream)){
          const subtype = obj.dict.get && obj.dict.get(PDFName.of('Subtype'));
          const params = obj.dict.get && obj.dict.get(PDFName.of('Params'));
          let isJson=false;
          if(String(subtype)==='/EmbeddedFile'){
            const fn = params ? (pdfDoc.context.lookup(params, PDFDict)?.get(PDFName.of('ModDate'))):null;
            // Can't always read names here; just try by size type.
            // We'll sniff later.
            isJson=true;
          }
          if(isJson){
            const contents = obj.getContents ? obj.getContents() : obj.contents;
            if(contents){
              const u8 = contents instanceof Uint8Array ? contents : new Uint8Array(contents);
              // quick sniff
              const head = new TextDecoder().decode(u8.slice(0,20));
              if(head.trim().startsWith('{') || head.includes('"serial"') || head.includes('"tag_b64"')) return u8;
            }
          }
        }
      }
    }catch(_e2){ /* ignore */ }
    return null;
  }

  async function tryGetEmbeddedAttachmentBytes(pdfDoc){
    const { PDFName, PDFDict, PDFRawStream, PDFStream } = window.PDFLib;
    // Prefer Filespec EF entries for PNG
    try{
      for(const [ref, obj] of pdfDoc.context.enumerateIndirectObjects()){
        if(obj && obj.dict && obj.dict.get){
          const type = obj.dict.get(PDFName.of('Type'));
          if(String(type)==='/Filespec'){
            const ef = obj.dict.get(PDFName.of('EF'));
            if(ef){
              const efDict = pdfDoc.context.lookup(ef, PDFDict);
              const keys = efDict.keys? efDict.keys(): [];
              for(const k of keys){
                const streamRef = efDict.get ? efDict.get(k) : null;
                if(!streamRef) continue;
                const stream = pdfDoc.context.lookup(streamRef);
                if(stream && (stream instanceof PDFRawStream || stream instanceof PDFStream)){
                  const contents = stream.getContents ? stream.getContents() : stream.contents;
                  if(contents){
                    const u8 = contents instanceof Uint8Array ? contents : new Uint8Array(contents);
                    // Prefer PNG/JPEG-like by signature
                    if(u8.length>=8 && u8[0]===0x89 && u8[1]===0x50 && u8[2]===0x4E && u8[3]===0x47) return { bytes:u8 }; // PNG
                    if(u8.length>=3 && u8[0]===0xFF && u8[1]===0xD8 && u8[2]===0xFF) return { bytes:u8 }; // JPEG
                  }
                }
              }
            }
          }
        }
      }
    }catch(_e){ /* ignore */ }

    // Fallback: any EmbeddedFile streams
    try{
      for(const [ref, obj] of pdfDoc.context.enumerateIndirectObjects()){
        if(obj && (obj instanceof PDFRawStream || obj instanceof PDFStream)){
          const subtype = obj.dict.get && obj.dict.get(PDFName.of('Subtype'));
          if(String(subtype)==='/EmbeddedFile'){
            const contents = obj.getContents ? obj.getContents() : obj.contents;
            if(contents){
              const u8 = contents instanceof Uint8Array ? contents : new Uint8Array(contents);
              // Try image-like first
              if(u8.length>=8 && u8[0]===0x89 && u8[1]===0x50 && u8[2]===0x4E && u8[3]===0x47) return { bytes:u8 };
              if(u8.length>=3 && u8[0]===0xFF && u8[1]===0xD8 && u8[2]===0xFF) return { bytes:u8 };
            }
          }
        }
      }
    }catch(_e2){ /* ignore */ }

    return null;
  }

  async function analyzeImageBytes(u8){
    // Try PNG then JPEG
    try{
      const blob = new Blob([u8], { type: 'image/png' });
      const url = URL.createObjectURL(blob);
      const img = await loadImageFromURL(url);
      URL.revokeObjectURL(url);
      const c = document.createElement('canvas'); c.width = img.naturalWidth||img.width; c.height = img.naturalHeight||img.height;
      const cx = c.getContext('2d', { willReadFrequently:true });
      cx.drawImage(img, 0, 0);
      const id = cx.getImageData(0,0,c.width,c.height);
      const pixelsHashRGBA = await sha256(id.data.buffer);
      const pixelsHashRGB  = await hashRGBFromImageDataDataBuffer(id.data);
      const extractedTag   = extractDataLSB(cx);
      return { pixelsHashRGBA, pixelsHashRGB, extractedTag };
    }catch(e){
      try{
        const blob = new Blob([u8], { type: 'image/jpeg' });
        const url = URL.createObjectURL(blob);
        const img = await loadImageFromURL(url);
        URL.revokeObjectURL(url);
        const c = document.createElement('canvas'); c.width = img.naturalWidth||img.width; c.height = img.naturalHeight||img.height;
        const cx = c.getContext('2d', { willReadFrequently:true });
        cx.drawImage(img, 0, 0);
        const id = cx.getImageData(0,0,c.width,c.height);
        const pixelsHashRGBA = await sha256(id.data.buffer);
        const pixelsHashRGB  = await hashRGBFromImageDataDataBuffer(id.data);
        const extractedTag   = extractDataLSB(cx);
        return { pixelsHashRGBA, pixelsHashRGB, extractedTag };
      }catch(_e2){
        return null;
      }
    }
  }
  function loadImageFromURL(url){
    return new Promise((res,rej)=>{
      const img=new Image();
      img.onload=()=>res(img);
      img.onerror=rej;
      img.src=url;
    });
  }

  /* ---------- Strategy A: pdf-lib traversal ---------- */
  async function extractImageLikeWithPdfLib(pdfDoc, types){
    const { PDFName, PDFDict, PDFRawStream, PDFStream } = types;
    const pages=pdfDoc.getPages();
    if(pages.length){
      const page=pages[0];
      try{
        const Resources=page.node.Resources && page.node.Resources();
        if(Resources){
          const xobjDict = Resources.lookup && Resources.lookup(PDFName.of('XObject'), PDFDict);
          if(xobjDict){
            const keys = xobjDict.keys ? xobjDict.keys() : [];
            for(const k of keys){
              let obj = xobjDict.lookup ? xobjDict.lookup(k) : null;
              if(!obj && xobjDict.get) obj = xobjDict.get(k);
              if(obj && pdfDoc.context.lookup) obj = pdfDoc.context.lookup(obj);
              const stream = obj;
              if(stream && (stream instanceof PDFRawStream || stream instanceof PDFStream)){
                const subtype = stream.dict.get && stream.dict.get(PDFName.of('Subtype'));
                if(String(subtype)==='/Image'){
                  const maybeBytes = stream.getContents ? stream.getContents() : stream.contents;
                  if(maybeBytes && maybeBytes.byteLength){
                    const u8 = maybeBytes instanceof Uint8Array ? maybeBytes : new Uint8Array(maybeBytes);
                    if(u8.length>=8 && u8[0]===0x89 && u8[1]===0x50 && u8[2]===0x4E && u8[3]===0x47){
                      const b64 = u8ToBase64(u8);
                      return { kind:'png-dataurl', dataURL:`data:image/png;base64,${b64}` };
                    }
                    const width = numFromDict(stream.dict, PDFName.of('Width'));
                    const height= numFromDict(stream.dict, PDFName.of('Height'));
                    const bpc   = numFromDict(stream.dict, PDFName.of('BitsPerComponent')) || 8;
                    const cs    = stream.dict.get(PDFName.of('ColorSpace'));
                    const comps = (/DeviceCMYK/.test(String(cs)))?4 : (/DeviceGray/.test(String(cs)))?1 : 3;
                    return { kind:'raw-pixels', width, height, bpc, comps, bytes: u8 };
                  }
                }
              }
            }
          }
        }
      }catch(e){ /* fall through */ }
    }

    // Fallback: scan every indirect object for an Image stream
    try{
      for(const [ref, obj] of pdfDoc.context.enumerateIndirectObjects()){
        if(obj && (obj instanceof types.PDFRawStream || obj instanceof types.PDFStream)){
          const subtype = obj.dict.get && obj.dict.get(types.PDFName.of('Subtype'));
          if(String(subtype)==='/Image'){
            const maybeBytes = obj.getContents ? obj.getContents() : obj.contents;
            if(maybeBytes && maybeBytes.byteLength){
              const u8 = maybeBytes instanceof Uint8Array ? maybeBytes : new Uint8Array(maybeBytes);
              if(u8.length>=8 && u8[0]===0x89 && u8[1]===0x50 && u8[2]===0x4E && u8[3]===0x47){
                const b64=u8ToBase64(u8);
                return { kind:'png-dataurl', dataURL:`data:image/png;base64,${b64}` };
              }
              const width = numFromDict(obj.dict, types.PDFName.of('Width'));
              const height= numFromDict(obj.dict, types.PDFName.of('Height'));
              const bpc   = numFromDict(obj.dict, types.PDFName.of('BitsPerComponent')) || 8;
              const cs    = obj.dict.get(types.PDFName.of('ColorSpace'));
              const comps = (/DeviceCMYK/.test(String(cs)))?4 : (/DeviceGray/.test(String(cs)))?1 : 3;
              return { kind:'raw-pixels', width, height, bpc, comps, bytes:u8 };
            }
          }
        }
      }
    }catch(e){ /* ignore */ }

    return null;
  }
  function numFromDict(dict, name){
    try{
      const x=dict.get(name);
      if(!x) return null;
      const s=String(x).replace(/[^\d.]/g,'');
      const n=Number(s); return Number.isFinite(n)? n:null;
    }catch{ return null; }
  }

  async function hashAndExtractFromDataURL(dataURL){
    const img = await loadImageFromDataURL(dataURL);
    const c=document.createElement('canvas'); c.width=img.naturalWidth||img.width; c.height=img.naturalHeight||img.height;
    const cx=c.getContext('2d',{ willReadFrequently:true });
    cx.drawImage(img,0,0);
    const idata=cx.getImageData(0,0,c.width,c.height);
    const pixelsHashRGBA=await sha256(idata.data.buffer);
    const pixelsHashRGB =await hashRGBFromImageDataDataBuffer(idata.data);
    const extractedTag=extractDataLSB(cx);
    return { pixelsHashRGBA, pixelsHashRGB, extractedTag };
  }
  function loadImageFromDataURL(dataURL){
    return new Promise((res,rej)=>{
      const img=new Image();
      img.onload=()=>res(img);
      img.onerror=rej;
      img.src=dataURL;
    });
  }

  async function drawRawPixelsAndAnalyze(info){
    const { width,height,comps,bpc,bytes } = info;
    if(!width||!height||!bytes) return {};
    const c=document.createElement('canvas'); c.width=width; c.height=height;
    const cx=c.getContext('2d',{ willReadFrequently:true });
    const imgData=cx.createImageData(width,height);
    const dst=imgData.data;

    if(bpc!==8) return {};
    let si=0, di=0;
    try{
      if(comps===3){ // RGB
        for(let i=0;i<width*height;i++){ dst[di++]=bytes[si++]; dst[di++]=bytes[si++]; dst[di++]=bytes[si++]; dst[di++]=255; }
      }else if(comps===1){ // Gray
        for(let i=0;i<width*height;i++){ const g=bytes[si++]; dst[di++]=g; dst[di++]=g; dst[di++]=g; dst[di++]=255; }
      }else if(comps===4){ // CMYK to RGB (approx)
        for(let i=0;i<width*height;i++){
          const c0=bytes[si++]/255, m=bytes[si++]/255, y=bytes[si++]/255, k=bytes[si++]/255;
          const r=255*(1-Math.min(1,c0*(1-k)+k));
          const g=255*(1-Math.min(1,m *(1-k)+k));
          const b=255*(1-Math.min(1,y *(1-k)+k));
          dst[di++]=r|0; dst[di++]=g|0; dst[di++]=b|0; dst[di++]=255;
        }
      }else{ return {}; }
      cx.putImageData(imgData,0,0);
      const rgbaHash = await sha256(imgData.data.buffer);
      const rgbHash  = await hashRGBFromImageDataDataBuffer(imgData.data);
      const tag=extractDataLSB(cx);
      return { pixelsHashRGBA:rgbaHash, pixelsHashRGB:rgbHash, extractedTag:tag };
    }catch{ return {}; }
  }

  /* ---------- Display & errors ---------- */
  function displayVerificationResult(result, payload={}){
    id('verify-loading').classList.remove('active');
    id('verify-result').classList.add('active');
    id('auth-prob').textContent=`Authenticity: ${result.status}`;
    const details=id('result-card-details');
    details.className=`result-card ${String(result.status||'LOW').toLowerCase()}`;
    details.innerHTML=`
      <h4>${result.status==='HIGH'?'✓':(result.status==='MEDIUM'?'⚠️':'✗')} Verification ${result.status}</h4>
      <ul class="verification-breakdown">
        <li><span class="icon ${result.crypto==='OK'?'ok':'fail'}">${result.crypto==='OK'?'✓':'✗'}</span> Cryptographic Signature: <strong>${result.crypto==='OK'?'Valid':'Invalid'}</strong></li>
        <li><span class="icon ${result.water==='OK'?'ok':(result.water==='SKIPPED'?'':'fail')}">${result.water==='OK'?'✓':(result.water==='SKIPPED'?'•':'✗')}</span> Watermark Integrity: <strong>${result.water==='OK'?'Matched':(result.water==='SKIPPED'?'Skipped':'Mismatch/Missing')}</strong></li>
        <li><span class="icon ${result.hash==='OK'?'ok':(result.hash==='SKIPPED'?'':'fail')}">${result.hash==='OK'?'✓':(result.hash==='SKIPPED'?'•':'✗')}</span> Image Hash Consistency: <strong>${result.hash==='OK'?'Matched':(result.hash==='SKIPPED'?'Skipped':'Mismatch')}</strong></li>
      </ul>
      ${payload.serial?`<p><strong>Serial:</strong> ${payload.serial}</p>`:''}
      ${payload.name?`<p><strong>Name:</strong> ${payload.name}</p>`:''}
      ${payload.date?`<p><strong>Date:</strong> ${payload.date}</p>`:''}
      ${result.error?`<p><strong>Error:</strong> ${result.error}</p>`:''}
    `;
  }
  function showError(msg,details){ id('error-message').textContent=msg||'Unknown Error'; id('error-details').textContent=details||''; id('error-modal').style.display='flex'; }

  /* ---------- Start ---------- */
  init();
});
</script>
</body>
</html>
