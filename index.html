<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>CarbonAra — Secure Certificate</title>

  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Great+Vibes&family=Montserrat:wght@400;600;700&display=swap" rel="stylesheet" />

  <!-- Libs -->
  <script src="https://unpkg.com/pdf-lib/dist/pdf-lib.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/qrious@4.0.2/dist/qrious.min.js"></script>

  <style>
    :root{
      --bg:#f8f9fa; --card:#fff; --text:#212529; --muted:#6c757d; --border:#dee2e6;
      --primary:#0d6efd; --primary-hover:#0b5ed7;
      --ok:#198754; --warn:#ffc107; --bad:#dc3545;
      --shadow:0 10px 30px rgba(0,0,0,.06);
    }
    [data-theme="dark"]{
      --bg:#111; --card:#1a1a1a; --text:#e9ecef; --muted:#adb5bd; --border:#343a40;
      --primary:#4dabf7; --primary-hover:#74c0fc;
      --shadow:0 10px 30px rgba(0,0,0,.35);
    }
    *{box-sizing:border-box}
    body{margin:0;background:var(--bg);color:var(--text);font:14px/1.5 Montserrat,system-ui,sans-serif;overflow:hidden}
    header{display:flex;align-items:center;justify-content:space-between;padding:12px 20px;background:var(--card);border-bottom:1px solid var(--border);position:sticky;top:0;z-index:5}
    header .brand{display:flex;gap:10px;align-items:center}
    header .brand svg{width:28px;height:28px;fill:var(--primary)}
    header h1{font-size:18px;margin:0}
    .btn{display:inline-flex;align-items:center;justify-content:center;gap:8px;border:none;border-radius:8px;background:var(--primary);color:#fff;padding:10px 14px;font-weight:700;cursor:pointer}
    .btn:hover{background:var(--primary-hover)}
    .btn.secondary{background:#6c757d}.btn.secondary:hover{background:#5a6268}
    .grid{display:flex;height:calc(100vh - 58px)}
    aside{width:380px;min-width:360px;background:var(--card);border-right:1px solid var(--border);overflow:auto;padding:16px}
    .tabs{display:flex;border-bottom:1px solid var(--border);gap:10px;margin-bottom:10px}
    .tab{background:transparent;border:none;padding:10px 12px;border-bottom:3px solid transparent;color:var(--muted);font-weight:700;cursor:pointer}
    .tab.active{color:var(--primary);border-color:var(--primary)}
    .pane{display:none}.pane.active{display:block}
    details{border:1px solid var(--border);border-radius:8px;margin-bottom:10px;overflow:hidden}
    summary{padding:12px;background:rgba(0,0,0,.03);cursor:pointer;font-weight:700}
    .panel{padding:12px}
    label{display:block;font-size:11px;color:var(--muted);text-transform:uppercase;margin:10px 0 6px}
    input,select{width:100%;background:var(--bg);color:var(--text);border:1px solid var(--border);border-radius:8px;padding:10px}
    .row{display:flex;gap:10px}
    .preview-wrap{flex:1;display:flex;align-items:center;justify-content:center;overflow:auto;padding:18px}
    .frame{background:var(--card);border:1px solid var(--border);border-radius:12px;box-shadow:var(--shadow);padding:16px;transform-origin:center}
    canvas{border:1px solid var(--border);cursor:grab}
    .meta{display:flex;justify-content:space-between;align-items:center;margin-top:8px;font-size:12px;color:var(--muted)}
    .zoom button{all:unset;background:transparent;cursor:pointer;padding:2px 8px;border:1px solid var(--border);border-radius:6px}
    hr{border:none;border-top:1px solid var(--border);margin:16px 0}
    .result{padding:16px;border-radius:10px;border:1px solid var(--border)}
    .result.high{border-color:var(--ok);background:rgba(25,135,84,.1)}
    .result.medium{border-color:#e0a800;background:rgba(255,193,7,.12)}
    .result.low{border-color:var(--bad);background:rgba(220,53,69,.12)}
    .list{list-style:none;padding:0;margin:10px 0}
    .list li{display:flex;gap:8px;align-items:center;margin:6px 0}
    #diag{white-space:pre-wrap;background:var(--bg);border:1px dashed var(--border);border-radius:8px;padding:10px;max-height:260px;overflow:auto}
    .modal{position:fixed;inset:0;background:rgba(0,0,0,.45);display:none;align-items:center;justify-content:center;z-index:50}
    .modal .card{background:var(--card);border:1px solid var(--border);border-radius:12px;box-shadow:var(--shadow);padding:18px;width:min(92vw,460px)}
    .progress{height:8px;background:var(--border);border-radius:6px;overflow:hidden}
    .progress>i{display:block;height:100%;width:0;background:var(--primary);transition:width .25s}
    .error{font:12px/1.4 ui-monospace,Menlo,Consolas,monospace;background:var(--bg);border:1px solid var(--border);border-radius:8px;padding:10px;max-height:220px;overflow:auto}
  </style>
</head>
<body>
<header>
  <div class="brand">
    <svg viewBox="0 0 24 24"><path d="M12 2a10 10 0 1 0 .001 20.001A10 10 0 0 0 12 2zm-1 14.5L6.5 12 7.91 10.59 11 13.67 16.09 8.59 17.5 10 11 16.5z"/></svg>
    <h1>CarbonAra</h1>
  </div>
  <button id="theme" class="btn secondary" title="Toggle theme">🌙</button>
</header>

<div class="grid">
  <aside>
    <div class="tabs">
      <button class="tab active" data-tab="gen">Generate</button>
      <button class="tab" data-tab="ver">Verify</button>
    </div>

    <div id="pane-gen" class="pane active">
      <details open>
        <summary>1) Setup & Branding</summary>
        <div class="panel">
          <label>Background Image <small id="bg-status" style="float:right;color:var(--muted)"></small></label>
          <input type="file" accept="image/png,image/jpeg" id="bg-file" />
          <label>Logo (optional)</label>
          <input type="file" accept="image/png,image/jpeg" id="logo-file" />
        </div>
      </details>

      <details open>
        <summary>2) Certificate Data</summary>
        <div class="panel">
          <label>Name</label><input id="name" value="John Doe" />
          <label>Amount</label><input id="amount" value="100" />
          <label>Date</label><input id="date" type="date" />
          <label>Type</label><input id="ctype" value="Carbon Credit" />
          <label>Serial</label>
          <div class="row">
            <input id="serial" readonly />
            <button class="btn secondary" id="regen" type="button" style="min-width:120px">New Serial</button>
          </div>
        </div>
      </details>

      <details>
        <summary>3) Layout & Style</summary>
        <div class="panel">
          <label>Name font size</label><input id="fs-name" type="number" min="12" value="100" />
          <div class="row">
            <div style="flex:1"><label>X(name)</label><input id="x-name" type="number" step="0.0001" /></div>
            <div style="flex:1"><label>Y(name)</label><input id="y-name" type="number" step="0.0001" /></div>
          </div>
          <label>Other font size</label><input id="fs-other" type="number" min="10" value="33" />
          <div class="row">
            <div style="flex:1"><label>X(amount)</label><input id="x-amt" type="number" step="0.0001" /></div>
            <div style="flex:1"><label>Y(amount)</label><input id="y-amt" type="number" step="0.0001" /></div>
          </div>
          <div class="row">
            <div style="flex:1"><label>X(date)</label><input id="x-date" type="number" step="0.0001" /></div>
            <div style="flex:1"><label>Y(date)</label><input id="y-date" type="number" step="0.0001" /></div>
          </div>
          <div class="row">
            <div style="flex:1"><label>X(type)</label><input id="x-type" type="number" step="0.0001" /></div>
            <div style="flex:1"><label>Y(type)</label><input id="y-type" type="number" step="0.0001" /></div>
          </div>
          <label>Serial font size</label><input id="fs-serial" type="number" min="8" value="22" />
          <div class="row">
            <div style="flex:1"><label>X(serial)</label><input id="x-serial" type="number" step="0.0001" /></div>
            <div style="flex:1"><label>Y(serial)</label><input id="y-serial" type="number" step="0.0001" /></div>
          </div>
          <label>Logo X,Y,Width</label>
          <div class="row">
            <input id="x-logo" type="number" value="50" />
            <input id="y-logo" type="number" value="50" />
            <input id="w-logo" type="number" value="200" />
          </div>
          <div class="row" style="margin-top:8px">
            <button id="align-x" class="btn secondary" type="button">Align X for Amount & Type</button>
            <button id="reset-pos" class="btn secondary" type="button">Reset Positions</button>
          </div>
        </div>
      </details>

      <details>
        <summary>4) Export Options</summary>
        <div class="panel">
          <label>DPI</label>
          <select id="dpi"><option>150</option><option selected>300</option></select>
          <label>QR Code</label>
          <select id="qr-mode"><option value="with_qr">With QR</option><option value="no_qr">No QR</option></select>
          <div id="qr-opts">
            <div class="row">
              <div style="flex:1"><label>QR X</label><input id="x-qr" type="number" /></div>
              <div style="flex:1"><label>QR Y</label><input id="y-qr" type="number" /></div>
            </div>
            <label>QR Alpha</label><input id="a-qr" type="range" min="0" max="1" step="0.05" value="0.8" />
            <button class="btn secondary" id="reset-qr" type="button" style="margin-top:8px">Reset QR</button>
          </div>
          <hr />
          <button id="export" class="btn" type="button">🔒 Generate PDF</button>
        </div>
      </details>
    </div>

    <div id="pane-ver" class="pane">
      <div class="panel">
        <p style="margin-top:0">Upload a CarbonAra PDF for verification.</p>
        <input type="file" id="ver-file" accept="application/pdf" />
      </div>
      <div class="panel">
        <div id="ver-card" class="result medium">
          <strong id="ver-title">Waiting for file…</strong>
          <ul class="list" id="ver-list"></ul>
          <div id="ver-meta"></div>
        </div>
      </div>
      <details>
        <summary>Expert Diagnostics</summary>
        <div class="panel">
          <div id="diag">No data.</div>
          <button class="btn secondary" id="copy-diag" type="button" style="margin-top:8px">Copy</button>
        </div>
      </details>
    </div>
  </aside>

  <div class="preview-wrap">
    <div class="frame" id="frame">
      <canvas id="cv"></canvas>
      <div class="meta">
        <span id="dims">—</span>
        <span class="zoom">
          <button id="z-">−</button>
          <b id="zval">100%</b>
          <button id="z+">+</button>
        </span>
      </div>
    </div>
  </div>
</div>

<!-- Progress / Error -->
<div id="modal" class="modal">
  <div class="card">
    <h3 style="margin:0 0 8px">Generating PDF…</h3>
    <p id="m-status" style="margin:0 0 8px">Initializing…</p>
    <div class="progress"><i id="m-bar"></i></div>
  </div>
</div>

<div id="emodal" class="modal">
  <div class="card">
    <h3 style="margin-top:0">Error</h3>
    <div class="error" id="err"></div>
    <div style="display:flex;justify-content:flex-end;margin-top:10px">
      <button class="btn secondary" id="eclose" type="button">Close</button>
    </div>
  </div>
</div>

<script>
/* ========== tiny utils ========== */
const $ = id => document.getElementById(id);
const on = (el, ev, fn) => el.addEventListener(ev, fn);
const deb = (fn,ms=20)=>{let t;return(...a)=>{clearTimeout(t);t=setTimeout(()=>fn(...a),ms)}}
const sleep = ms => new Promise(r=>setTimeout(r,ms));
const enc = s => new TextEncoder().encode(s);
const dec = b => new TextDecoder().decode(b);
const u8toB64 = u8 => btoa([...u8].map(x=>String.fromCharCode(x)).join(''));
const b64toU8 = b64 => new Uint8Array(atob(b64).split('').map(c=>c.charCodeAt(0)));
const abSha256Hex = async (ab) => {
  const h = new Uint8Array(await crypto.subtle.digest('SHA-256', ab));
  return [...h].map(x=>x.toString(16).padStart(2,'0')).join('');
};
const hashRGBA = async (rgbaU8) => abSha256Hex(rgbaU8.buffer);
const hashRGB = async (rgbaU8) => {
  const rgb = new Uint8Array((rgbaU8.length/4|0)*3);
  for(let s=0,d=0;s<rgbaU8.length;s+=4){ rgb[d++]=rgbaU8[s]; rgb[d++]=rgbaU8[s+1]; rgb[d++]=rgbaU8[s+2]; }
  return abSha256Hex(rgb.buffer);
};
const now = ()=>new Date().toLocaleTimeString();

/* ========== canvas & UI state ========== */
const cv = $('cv'), cx = cv.getContext('2d',{willReadFrequently:true});
const bg = new Image(), logo = new Image(); let qrImg = new Image();
let bgOK=false, logoOK=false, zoom=1, rendering=false;

const posDefaults = {
  fsName:100, xName:705.6404, yName:1005.7899,
  fsOther:33, xAmt:359.1387, yAmt:1531.1968,
  xDate:1068.8586, yDate:1527.7868,
  xType:359.1387, yType:1676.0735,
  fsSerial:22, xSerial:516.0143, ySerial:1943.9245,
  xLogo:50, yLogo:50, wLogo:200,
  xQR:1214, yQR:1800, aQR:.8
};

const inputs = {
  name:$('name'), amount:$('amount'), date:$('date'), ctype:$('ctype'), serial:$('serial'),
  fsName:$('fs-name'), fsOther:$('fs-other'), fsSerial:$('fs-serial'),
  xName:$('x-name'), yName:$('y-name'),
  xAmt:$('x-amt'), yAmt:$('y-amt'),
  xDate:$('x-date'), yDate:$('y-date'),
  xType:$('x-type'), yType:$('y-type'),
  xSerial:$('x-serial'), ySerial:$('y-serial'),
  xLogo:$('x-logo'), yLogo:$('y-logo'), wLogo:$('w-logo'),
  dpi:$('dpi'), qrMode:$('qr-mode'), xQR:$('x-qr'), yQR:$('y-qr'), aQR:$('a-qr')
};

const state = {
  text: {
    name:{x:0,y:0,size:posDefaults.fsName,font:'Great Vibes'},
    amount:{x:0,y:0,size:posDefaults.fsOther,font:'Montserrat'},
    date:{x:0,y:0,size:posDefaults.fsOther,font:'Montserrat'},
    type:{x:0,y:0,size:posDefaults.fsOther,font:'Montserrat'},
    serial:{x:0,y:0,size:posDefaults.fsSerial,font:'Montserrat'}
  },
  logo:{x:posDefaults.xLogo, y:posDefaults.yLogo, w:posDefaults.wLogo, h:0},
  qr:{x:posDefaults.xQR, y:posDefaults.yQR, a:posDefaults.aQR, size:150}
};

function setDefaults(){
  inputs.fsName.value=posDefaults.fsName;
  inputs.xName.value=posDefaults.xName; inputs.yName.value=posDefaults.yName;
  inputs.fsOther.value=posDefaults.fsOther;
  inputs.xAmt.value=posDefaults.xAmt; inputs.yAmt.value=posDefaults.yAmt;
  inputs.xDate.value=posDefaults.xDate; inputs.yDate.value=posDefaults.yDate;
  inputs.xType.value=posDefaults.xType; inputs.yType.value=posDefaults.yType;
  inputs.fsSerial.value=posDefaults.fsSerial;
  inputs.xSerial.value=posDefaults.xSerial; inputs.ySerial.value=posDefaults.ySerial;
  inputs.xLogo.value=posDefaults.xLogo; inputs.yLogo.value=posDefaults.yLogo; inputs.wLogo.value=posDefaults.wLogo;
  inputs.xQR.value=posDefaults.xQR; inputs.yQR.value=posDefaults.yQR; inputs.aQR.value=posDefaults.aQR;
}

/* ========== draw ========== */
function applyInputs(){
  state.text.name.size=+inputs.fsName.value||posDefaults.fsName;
  state.text.name.x=+inputs.xName.value||0; state.text.name.y=+inputs.yName.value||0;
  state.text.amount.size=+inputs.fsOther.value||posDefaults.fsOther;
  state.text.date.size=+inputs.fsOther.value||posDefaults.fsOther;
  state.text.type.size=+inputs.fsOther.value||posDefaults.fsOther;
  state.text.amount.x=+inputs.xAmt.value||0; state.text.amount.y=+inputs.yAmt.value||0;
  state.text.date.x=+inputs.xDate.value||0; state.text.date.y=+inputs.yDate.value||0;
  state.text.type.x=+inputs.xType.value||0; state.text.type.y=+inputs.yType.value||0;
  state.text.serial.size=+inputs.fsSerial.value||posDefaults.fsSerial;
  state.text.serial.x=+inputs.xSerial.value||0; state.text.serial.y=+inputs.ySerial.value||0;
  state.logo.x=+inputs.xLogo.value||0; state.logo.y=+inputs.yLogo.value||0; state.logo.w=+inputs.wLogo.value||0;
  state.logo.h = logoOK && state.logo.w>0 ? (logo.naturalHeight||logo.height) * (state.logo.w/Math.max(1,(logo.naturalWidth||logo.width))) : 0;
  state.qr.x=+inputs.xQR.value||0; state.qr.y=+inputs.yQR.value||0; state.qr.a=+inputs.aQR.value||.8;
}
function redraw(){
  if(rendering) return; rendering=true;
  requestAnimationFrame(()=>{
    applyInputs();
    cx.clearRect(0,0,cv.width,cv.height);
    if(bgOK) cx.drawImage(bg,0,0,cv.width,cv.height); else { cx.fillStyle='#fff'; cx.fillRect(0,0,cv.width,cv.height); }
    // logo
    if(logoOK && state.logo.w>0 && state.logo.h>0) cx.drawImage(logo,state.logo.x,state.logo.y,state.logo.w,state.logo.h);
    // text
    cx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--text').trim() || '#000';
    drawTextCentered(inputs.name.value||'', state.text.name);
    drawTextCentered(inputs.amount.value||'', state.text.amount);
    drawTextCentered(inputs.date.value||'', state.text.date);
    drawTextCentered(inputs.ctype.value||'', state.text.type);
    drawTextCentered(inputs.serial.value||'', state.text.serial);
    // QR
    if(inputs.qrMode.value==='with_qr' && qrImg.src){
      cx.globalAlpha = state.qr.a; cx.drawImage(qrImg, state.qr.x, state.qr.y, state.qr.size, state.qr.size); cx.globalAlpha = 1;
    }
    rendering=false;
  });
}
function drawTextCentered(text, spec){
  const size=+spec.size||12; cx.textBaseline='top'; cx.font=`${size}px '${spec.font||'Montserrat'}'`;
  const w = cx.measureText(text).width; cx.fillText(text, (spec.x||0) - w/2, spec.y||0);
}

/* ========== sizing / zoom ========== */
function setCanvasSize(w,h){
  cv.width=w; cv.height=h; $('dims').textContent = `${w} × ${h}px`;
}
function fit(){
  const frame = $('frame');
  const avail = frame.parentElement.getBoundingClientRect();
  const scale = Math.min((avail.width-48)/(frame.offsetWidth||1),(avail.height-48)/(frame.offsetHeight||1),1);
  zoom = scale; applyZoom(0);
}
function applyZoom(delta){
  zoom = Math.max(.2, Math.min(3, zoom+delta));
  $('frame').style.transform = `scale(${zoom})`;
  $('zval').textContent = `${Math.round(zoom*100)}%`;
}

/* ========== images & QR ========== */
function setBgDataURL(dataURL, name){
  bg.crossOrigin = 'anonymous';
  bg.onload=()=>{ bgOK=true; $('bg-status').textContent=`✅ ${name||'image.png'}`; setCanvasSize(bg.naturalWidth||1414,bg.naturalHeight||2000); resetPositions(); fit(); redraw(); };
  bg.onerror=()=>{ bgOK=false; $('bg-status').textContent='⚠️ failed'; setCanvasSize(1414,2000); resetPositions(); fit(); redraw(); };
  bg.src=dataURL;
}
async function handleBgFile(f){
  if(!f || !/^image\/(png|jpe?g)$/i.test(f.type)) return;
  const url = URL.createObjectURL(f);
  setBgDataURL(url, f.name);
}
async function handleLogoFile(f){
  if(!f || !/^image\/(png|jpe?g)$/i.test(f.type)) return;
  const url = URL.createObjectURL(f);
  logo.onload=()=>{ logoOK=true; redraw(); };
  logo.onerror=()=>{ logoOK=false; redraw(); };
  logo.src=url;
}
function regenQR(){
  if(inputs.qrMode.value!=='with_qr'){ qrImg.src=''; return; }
  const qrPayload = { s:inputs.serial.value, n:inputs.name.value, a:inputs.amount.value, d:inputs.date.value, t:inputs.ctype.value };
  const b64 = btoa(JSON.stringify(qrPayload)).replace(/\+/g,'-').replace(/\//g,'_').replace(/=+$/,'');
  const url = `${location.origin}${location.pathname}?verify=${b64}`;
  const q = new QRious({ value:url, size:512 });
  qrImg = new Image(); qrImg.src = q.toDataURL();
}

/* ========== positions ========== */
function resetPositions(){
  inputs.fsName.value = posDefaults.fsName;
  inputs.xName.value = posDefaults.xName; inputs.yName.value = posDefaults.yName;
  inputs.fsOther.value = posDefaults.fsOther;
  inputs.xAmt.value = posDefaults.xAmt; inputs.yAmt.value = posDefaults.yAmt;
  inputs.xDate.value = posDefaults.xDate; inputs.yDate.value = posDefaults.yDate;
  inputs.xType.value = posDefaults.xType; inputs.yType.value = posDefaults.yType;
  inputs.fsSerial.value = posDefaults.fsSerial;
  inputs.xSerial.value = posDefaults.xSerial; inputs.ySerial.value = posDefaults.ySerial;
  inputs.xLogo.value = posDefaults.xLogo; inputs.yLogo.value = posDefaults.yLogo; inputs.wLogo.value = posDefaults.wLogo;
  inputs.xQR.value = Math.max(0,(cv.width - state.qr.size - 50)); inputs.yQR.value = Math.max(0,(cv.height - state.qr.size - 50)); inputs.aQR.value = .8;
  applyInputs(); regenQR(); redraw();
}

/* ========== CRYPTO CORE (simple, deterministic) ========== */
const PBKDF2_ITER=100000, SALT='CarbonCertSaltV1';
async function hmacKey(){
  const base = await crypto.subtle.importKey('raw', enc('fragAfragBfragCfragD|pepper'), {name:'PBKDF2'}, false, ['deriveKey']);
  return crypto.subtle.deriveKey({name:'PBKDF2',salt:enc(SALT),iterations:PBKDF2_ITER,hash:'SHA-256'}, base, {name:'HMAC',hash:'SHA-256'}, true, ['sign','verify']);
}
function canonical(p){
  return [
    `v:${p.v}`,`serial:${p.serial}`,`name:${p.name}`,`amount:${p.amount}`,`date:${p.date}`,`type:${p.type}`,
    `imageHashAttachment:${p.imageHashAttachment}`,
    `imageHashRGBA:${p.imageHashRGBA}`,`imageHashRGB:${p.imageHashRGB}`,
    `posName:${p.posName.x},${p.posName.y}`,`posAmount:${p.posAmount.x},${p.posAmount.y}`,
    `posDate:${p.posDate.x},${p.posDate.y}`,`posType:${p.posType.x},${p.posType.y}`,
    `posSerial:${p.posSerial.x},${p.posSerial.y}`,`posLogo:${p.posLogo.x},${p.posLogo.y},${p.posLogo.w}`,
    `fontName:${p.fontName}`,`fontOther:${p.fontOther}`,`fontSerial:${p.fontSerial}`,
    `qrMode:${p.qrMode}`,`qrPos:${p.qrPos.x},${p.qrPos.y}`,`qrAlpha:${p.qrAlpha}`,
    `canvas:${p.canvas}`,`app:${p.app}`
  ].join('|');
}
async function signTag(canon){
  const key = await hmacKey();
  const digest = await crypto.subtle.digest('SHA-256', enc(canon));
  const sig = new Uint8Array(await crypto.subtle.sign('HMAC', key, digest));
  return btoa(String.fromCharCode(...sig));
}

/* ========== Watermark (LSB on blue) ========== */
function embedLSB(ctx,str){
  const END='::END::';
  const bits=[...str+END].map(c=>c.charCodeAt(0).toString(2).padStart(8,'0')).join('');
  const img = ctx.getImageData(0,0,ctx.canvas.width,ctx.canvas.height);
  const d=img.data; const cap=(d.length/4|0);
  if(bits.length>cap) throw new Error('Watermark too large for canvas');
  for(let i=0;i<bits.length;i++){ const idx=i*4+2; d[idx]=(d[idx]&0xFE)|(bits[i]==='1'); }
  ctx.putImageData(img,0,0); return bits.length;
}
function extractLSB(ctx){
  const img=ctx.getImageData(0,0,ctx.canvas.width,ctx.canvas.height), d=img.data;
  let bits=''; for(let i=0;i<d.length;i+=4) bits+=(d[i+2]&1);
  const bytes=bits.match(/.{1,8}/g)||[]; let s='';
  for(const b of bytes){ if(b.length<8) continue; s+=String.fromCharCode(parseInt(b,2)); if(s.endsWith('::END::')) return s.slice(0,-7); }
  return null;
}

/* ========== EXPORT (rethought, deterministic) ========== */
/*
   What changes vs your previous attempts?

   1) We STOP trying to match pdf-lib’s internal raw XObject pixels.
      Instead, we commit to verifying the PNG attachment BYTES we embed.
      The payload’s primary image hash is the SHA-256 over the exact attached PNG bytes.

   2) For extra assurance, we ALSO record hashes over decoded RGBA/RGB of the watermarked PNG
      (computed from the exact attachment bytes, re-decoded to a canvas). That makes
      verification succeed with either (a) attachment match OR (b) decoded pixel hashes match
      (useful if attachments get stripped but image pixels survive).

   3) We redundantly store the payload JSON as:
      - Title suffix ("… | carboncert,<b64>")
      - Keywords ["carboncert", "<b64>"] (with fallbacks to Subject/Author)
      - A JSON attachment
      - LSB watermark in the PNG bitmap ("TAG:...||CCJSON:<b64>")

   “HIGH” result policy:
      crypto tag OK AND (attachment hash OK OR (LSB tag OK AND any pixel-hash OK))
*/
async function exportPDF(){
  const modal=$('modal'), bar=$('m-bar'), msg=$('m-status');
  const step=(t,p)=>{ msg.textContent=t; bar.style.width=p; };
  modal.style.display='flex';

  try{
    step('Rendering base canvas…','8%'); await sleep(10);

    // 1) DRAW to a temp canvas (unwatermarked) for baseline
    const base = document.createElement('canvas'); base.width=cv.width; base.height=cv.height;
    const bx = base.getContext('2d',{willReadFrequently:true});
    // draw same as screen but in deterministic black text
    bx.fillStyle='#fff'; bx.fillRect(0,0,base.width,base.height);
    if(bgOK) bx.drawImage(bg,0,0,base.width,base.height);
    if(logoOK && state.logo.w>0 && state.logo.h>0) bx.drawImage(logo,state.logo.x,state.logo.y,state.logo.w,state.logo.h);
    // text
    const texts = [
      {val:inputs.name.value||'',spec:state.text.name},
      {val:inputs.amount.value||'',spec:state.text.amount},
      {val:inputs.date.value||'',spec:state.text.date},
      {val:inputs.ctype.value||'',spec:state.text.type},
      {val:inputs.serial.value||'',spec:state.text.serial},
    ];
    bx.fillStyle='#000';
    for(const t of texts){ bx.font=`${t.spec.size}px '${t.spec.font}'`; const w=bx.measureText(t.val).width; bx.fillText(t.val, t.spec.x - w/2, t.spec.y); }
    // QR
    if(inputs.qrMode.value==='with_qr' && qrImg.src){ bx.globalAlpha=state.qr.a; bx.drawImage(qrImg,state.qr.x,state.qr.y,state.qr.size,state.qr.size); bx.globalAlpha=1; }

    // 2) First tag (temporary) -> watermark -> finalize tag
    step('Building payload (pass 1)…','22%');
    const payloadBase = () => ({
      v:1,
      serial: inputs.serial.value, name:(inputs.name.value||'').normalize('NFC'),
      amount:inputs.amount.value||'', date:inputs.date.value||'', type:(inputs.ctype.value||'').normalize('NFC'),
      imageHashAttachment:'', imageHashRGBA:'', imageHashRGB:'',
      posName:{x:state.text.name.x.toFixed(4), y:state.text.name.y.toFixed(4)},
      posAmount:{x:state.text.amount.x.toFixed(4), y:state.text.amount.y.toFixed(4)},
      posDate:{x:state.text.date.x.toFixed(4), y:state.text.date.y.toFixed(4)},
      posType:{x:state.text.type.x.toFixed(4), y:state.text.type.y.toFixed(4)},
      posSerial:{x:state.text.serial.x.toFixed(4), y:state.text.serial.y.toFixed(4)},
      posLogo:{x:state.logo.x.toFixed(4), y:state.logo.y.toFixed(4), w:(state.logo.w||0).toFixed(4)},
      fontName:`GreatVibes-${state.text.name.size}px`,
      fontOther:`Montserrat-${state.text.amount.size}px`,
      fontSerial:`Montserrat-${state.text.serial.size}px`,
      qrMode:inputs.qrMode.value, qrPos:{x:state.qr.x.toFixed(4), y:state.qr.y.toFixed(4)}, qrAlpha:state.qr.a.toFixed(2),
      canvas:`${cv.width}x${cv.height}@${inputs.dpi.value}`, app:'CarbonCert-5.0.0'
    });

    // (A) make watermarked PNG with provisional tag string
    const cW = document.createElement('canvas'); cW.width=cv.width; cW.height=cv.height;
    const xW = cW.getContext('2d',{willReadFrequently:true}); xW.drawImage(base,0,0);
    let tmpPayload = payloadBase();
    let tmpTag = await signTag(canonical({...tmpPayload, imageHashAttachment:'0'.repeat(64), imageHashRGBA:'0'.repeat(64), imageHashRGB:'0'.repeat(64)}));
    embedLSB(xW, `TAG:${tmpTag}||CCJSON:pending`);
    const dataURL1 = cW.toDataURL('image/png');
    const png1 = dataURLtoU8(dataURL1);
    const img1 = await dataURLtoImage(dataURL1);
    const px1 = pixelsOf(img1);
    tmpPayload.imageHashAttachment = await abSha256Hex(png1.buffer);
    tmpPayload.imageHashRGBA = await hashRGBA(px1);
    tmpPayload.imageHashRGB  = await hashRGB(px1);
    const finalTag = await signTag(canonical(tmpPayload));

    // (B) re-watermark with final JSON
    step('Watermarking (pass 2)…','40%');
    const cF = document.createElement('canvas'); cF.width=cv.width; cF.height=cv.height;
    const xF = cF.getContext('2d',{willReadFrequently:true}); xF.drawImage(base,0,0);
    const jsonB64 = u8toB64(enc(JSON.stringify({...tmpPayload, tag_b64:finalTag})));
    embedLSB(xF, `TAG:${finalTag}||CCJSON:${jsonB64}`);
    const dataURLF = cF.toDataURL('image/png');
    const pngF = dataURLtoU8(dataURLF);
    const imgF = await dataURLtoImage(dataURLF);
    const pxF = pixelsOf(imgF);

    // recompute attachment/pixel hashes from the EXACT attachment we will embed
    const payload = payloadBase();
    payload.imageHashAttachment = await abSha256Hex(pngF.buffer);
    payload.imageHashRGBA = await hashRGBA(pxF);
    payload.imageHashRGB  = await hashRGB(pxF);
    const tagB64 = await signTag(canonical(payload));
    const jsonFinalU8 = enc(JSON.stringify({...payload, tag_b64:tagB64}));
    const jsonFinalB64 = u8toB64(jsonFinalU8);

    // 3) Compose PDF
    step('Composing PDF…','62%');
    const { PDFDocument } = window.PDFLib;
    const pdf = await PDFDocument.create();
    const page = pdf.addPage([cv.width, cv.height]);
    const img = await pdf.embedPng(pngF); // embed EXACT BYTES we hashed above
    page.drawImage(img,{x:0,y:0,width:cv.width,height:cv.height});

    // Attachments (PNG + JSON + tiny thumb to survive overzealous tooling)
    step('Embedding attachments…','72%');
    try{ await pdf.attach(pngF, `CarbonAra-${payload.serial}.png`, {mimeType:'image/png',description:'Raster used for this document',createDate:new Date(),modificationDate:new Date()}); }catch{}
    try{ await pdf.attach(jsonFinalU8, `carboncert-${payload.serial}.json`, {mimeType:'application/json',description:'CarbonAra payload',createDate:new Date(),modificationDate:new Date()}); }catch{}
    try{
      const thumb = await makeThumbPNG(pngF, 280);
      await pdf.attach(thumb, `thumb-${payload.serial}.png`, {mimeType:'image/png',description:'Preview thumbnail',createDate:new Date(),modificationDate:new Date()});
    }catch{}

    // Metadata redundancy
    step('Writing metadata…','82%');
    pdf.setProducer('CarbonAra'); pdf.setCreator('CarbonAra:PNG@PDF');
    try{ pdf.setTitle(`CarbonAra ${payload.serial} | carboncert,${jsonFinalB64}`);}catch{}
    try{ pdf.setKeywords(['carboncert', jsonFinalB64]); }catch{ try{ pdf.setSubject(`carboncert,${jsonFinalB64}`);}catch{ try{ pdf.setAuthor(`carboncert:${jsonFinalB64}`);}catch{} } }

    // Save
    step('Finalizing…','92%');
    const bytes = await pdf.save({useObjectStreams:false});

    step('Downloading…','100%'); download(bytes, `CarbonCert-${payload.serial}.pdf`, 'application/pdf');
  }catch(err){
    showError(String(err?.stack||err?.message||err));
  }finally{
    modal.style.display='none';
  }
}
function dataURLtoU8(d){const b=d.split(',')[1]||'';const bin=atob(b);const u=new Uint8Array(bin.length);for(let i=0;i<bin.length;i++)u[i]=bin.charCodeAt(i);return u;}
function dataURLtoImage(d){return new Promise((ok,err)=>{const i=new Image();i.onload=()=>ok(i);i.onerror=err;i.src=d;});}
function pixelsOf(img){const c=document.createElement('canvas'); c.width=img.naturalWidth||img.width; c.height=img.naturalHeight||img.height; const x=c.getContext('2d',{willReadFrequently:true}); x.drawImage(img,0,0); return x.getImageData(0,0,c.width,c.height).data;}
async function makeThumbPNG(pngU8, w){
  const url = URL.createObjectURL(new Blob([pngU8],{type:'image/png'}));
  const img = await dataURLtoImage(url);
  const ratio = (img.naturalWidth||img.width)/ (img.naturalHeight||img.height);
  const c = document.createElement('canvas'); c.width = w; c.height = Math.round(w/ratio);
  const x = c.getContext('2d'); x.drawImage(img,0,0,c.width,c.height);
  const d = c.toDataURL('image/png'); URL.revokeObjectURL(url);
  return dataURLtoU8(d);
}
function download(u8,name,type){ const blob=new Blob([u8],{type}); const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download=name; document.body.appendChild(a); a.click(); setTimeout(()=>{URL.revokeObjectURL(url); a.remove();},0); }
function showError(s){ $('err').textContent=s; $('emodal').style.display='flex'; }

/* ========== VERIFY (rethought, fail-safe) ========== */
/*
   Search order for payload JSON:
   1) Keywords second token, else Subject, else Author, else Title suffix
   2) JSON attachment (EmbeddedFile / Filespec)
   3) LSB from primary page bitmap (extracted via XObject raw image -> raster -> LSB)
*/
async function verifyPDF(file){
  const diag=$('diag'); diag.textContent=''; const log = s=>diag.textContent+=`[${now()}] ${s}\n`;
  const card=$('ver-card'), list=$('ver-list'), meta=$('ver-meta'), title=$('ver-title');
  list.innerHTML=''; meta.innerHTML=''; title.textContent='Analyzing…'; card.className='result medium';

  const setRow = (ok,label,val) => list.insertAdjacentHTML('beforeend', `<li>${ok===true?'✅':ok===false?'❌':'•'}  <b>${label}:</b>&nbsp;<span>${val}</span></li>`);

  try{
    const { PDFDocument, PDFName, PDFDict, PDFRawStream, PDFStream } = window.PDFLib;
    const bytes = await file.arrayBuffer();
    const pdf = await PDFDocument.load(bytes,{ignoreEncryption:true,throwOnInvalidObject:false});
    log('PDF document loaded successfully.');

    let payload=null, foundVia=null;

    // 1) keywords
    try{
      const kw = pdf.getKeywords?.()||null;
      if(Array.isArray(kw) && kw.length){
        const flag = kw.find(s=>typeof s==='string' && s.toLowerCase()==='carboncert');
        const b64  = kw.find(s=>typeof s==='string' && s!==flag && /^[A-Za-z0-9+/=]+$/.test(s) && s.length>20);
        if(flag && b64){ payload = JSON.parse(dec(b64toU8(b64))); foundVia='keywords'; }
      }
    }catch{}
    // 2) subject
    if(!payload){ try{ const s=pdf.getSubject?.(); if(typeof s==='string' && s.startsWith('carboncert,')){ payload = JSON.parse(dec(b64toU8(s.slice(11)))); foundVia='subject'; } }catch{} }
    // 3) author
    if(!payload){ try{ const a=pdf.getAuthor?.(); if(typeof a==='string' && a.startsWith('carboncert:')){ payload = JSON.parse(dec(b64toU8(a.slice(11)))); foundVia='author'; } }catch{} }
    // 4) title suffix
    if(!payload){ try{ const t=pdf.getTitle?.(); if(typeof t==='string'){ const i=t.indexOf('carboncert,'); if(i>=0){ const b=t.slice(i+11).trim(); if(/^[A-Za-z0-9+/=]+$/.test(b)&&b.length>20){ payload = JSON.parse(dec(b64toU8(b))); foundVia='title'; } } } }catch{} }
    // 5) JSON attachment
    if(!payload){
      try{
        const u8 = await findJsonAttachment(pdf);
        if(u8){ payload = JSON.parse(dec(u8)); foundVia='attachment-json'; }
      }catch{}
    }
    // 6) LSB
    if(!payload){
      try{
        log('Attempting LSB payload recovery…');
        const info = await extractPrimaryImage(pdf, {PDFName,PDFDict,PDFRawStream,PDFStream});
        if(info){
          const analysis = await rasterAndRead(info);
          if(analysis && analysis.embeddedJSON){ payload = analysis.embeddedJSON; foundVia='lsb-payload'; }
        }
      }catch(e){ log('LSB recovery failed: '+(e?.message||e)); }
    }

    if(!payload) throw new Error('No CarbonAra payload found in metadata/attachments/LSB.');

    log(`Payload found via: ${foundVia}.`);
    const tagExpected = await signTag(canonical(payload));
    log(`Expected tag: ${tagExpected.slice(0,16)}…`);
    const tagMeta = payload.tag_b64||''; log(`Metadata tag: ${tagMeta.slice(0,16)}…`);

    // baseline (crypto)
    let cryptoOK = (tagExpected===tagMeta);

    // Strategy A: attachment bytes
    let attachOK=false, pixelOK=false, lsbOK=false;
    const attach = await findRasterAttachment(pdf);
    if(attach){
      const h = await abSha256Hex(attach.buffer);
      log(`Attachment hash: ${h.slice(0,16)}… vs payload ${String(payload.imageHashAttachment||'').slice(0,16)}…`);
      attachOK = (h===payload.imageHashAttachment);
      // pixel hashes & LSB tag from attachment image itself
      const ana = await analyzeImageU8(attach);
      if(ana){
        if(ana.rgba===payload.imageHashRGBA || ana.rgb===payload.imageHashRGB) pixelOK=true;
        if(ana.tag && ana.tag===tagMeta) lsbOK=true;
      }
    }else{
      log('No PNG/JPEG attachment present.');
    }

    // Strategy B: extract XObject image and check pixels/LSB
    if(!pixelOK || !lsbOK){
      const info = await extractPrimaryImage(pdf, {PDFName,PDFDict,PDFRawStream,PDFStream});
      if(info){
        const ro = await rasterOnly(info);
        if(ro){
          log(`B(raw): RGBA calc ${ro.rgba?.slice(0,16)||'n/a'}… vs payload ${payload.imageHashRGBA.slice(0,16)}…`);
          log(`B(raw): RGB  calc ${ro.rgb?.slice(0,16)||'n/a'}… vs payload ${payload.imageHashRGB.slice(0,16)}…`);
          if(ro.rgba===payload.imageHashRGBA || ro.rgb===payload.imageHashRGB) pixelOK=true;
          if(ro.tag && ro.tag===tagMeta) lsbOK=true;
        }
      }
    }

    // Decide score (simple & strict, but tolerant to missing attachments)
    // HIGH  = cryptoOK && (attachOK || (lsbOK && pixelOK))
    // MED   = cryptoOK (but attachments/pixels inconclusive)
    // LOW   = otherwise
    let status='LOW';
    if(cryptoOK && (attachOK || (lsbOK && pixelOK))) status='HIGH';
    else if(cryptoOK) status='MEDIUM';

    // UI
    title.textContent = `Authenticity: ${status}`;
    card.className = `result ${status.toLowerCase()}`;
    setRow(cryptoOK,'Cryptographic Signature', cryptoOK?'Valid':'Invalid');
    setRow(attachOK===null?'•':attachOK,'Image Hash (Attachment)', attachOK? 'Matched' : (attachOK===false?'Mismatch':'Skipped'));
    setRow(lsbOK===null?'•':lsbOK,'Watermark Integrity', lsbOK? 'Matched':'Mismatch/Absent');
    setRow(pixelOK===null?'•':pixelOK,'Pixel Hash Consistency', pixelOK? 'Matched':'Mismatch/Skipped');

    const fields = ['serial','name','date','type','amount'];
    meta.innerHTML = fields.map(k=>payload[k]?`<div><b>${k[0].toUpperCase()+k.slice(1)}:</b> ${payload[k]}</div>`:'').join('');

  }catch(err){
    $('ver-title').textContent='Authenticity: LOW';
    $('ver-card').className='result low';
    $('ver-list').innerHTML='';
    $('ver-meta').innerHTML='';
    $('diag').textContent += `CRITICAL ERROR: ${String(err?.message||err)}\n`;
    ['Cryptographic Signature','Watermark Integrity','Image Hash'].forEach(lbl=>{
      $('ver-list').insertAdjacentHTML('beforeend', `<li>❌  <b>${lbl}:</b>&nbsp;Error</li>`);
    });
  }
}
async function findJsonAttachment(pdf){
  const { PDFName, PDFDict, PDFStream, PDFRawStream } = window.PDFLib;
  for(const [ref,obj] of pdf.context.enumerateIndirectObjects()){
    if(obj && obj.dict && obj.dict.get){
      const t=obj.dict.get(PDFName.of('Subtype'));
      if(String(t)==='/EmbeddedFile'){
        const bytes = obj.getContents ? obj.getContents() : obj.contents;
        if(bytes){
          const u8 = bytes instanceof Uint8Array? bytes : new Uint8Array(bytes);
          const head = dec(u8.slice(0,40));
          if(head.trim().startsWith('{')) return u8;
        }
      }
    }
  }
  // Filespec route
  for(const [ref,obj] of pdf.context.enumerateIndirectObjects()){
    if(obj && obj.dict && obj.dict.get){
      const t=obj.dict.get(PDFName.of('Type'));
      if(String(t)==='/Filespec'){
        const ef = obj.dict.get(PDFName.of('EF'));
        if(ef){
          const efDict = pdf.context.lookup(ef, PDFDict);
          for(const k of (efDict.keys? efDict.keys():[])){
            const sref = efDict.get(k);
            const stream = pdf.context.lookup(sref);
            if(stream && (stream instanceof PDFStream || stream instanceof PDFRawStream)){
              const bytes = stream.getContents? stream.getContents(): stream.contents;
              if(bytes){
                const u8 = bytes instanceof Uint8Array? bytes : new Uint8Array(bytes);
                const head = dec(u8.slice(0,40));
                if(head.trim().startsWith('{')) return u8;
              }
            }
          }
        }
      }
    }
  }
  return null;
}
async function findRasterAttachment(pdf){
  const { PDFName, PDFStream, PDFRawStream } = window.PDFLib;
  for(const [ref,obj] of pdf.context.enumerateIndirectObjects()){
    if(obj && obj.dict && obj.dict.get){
      const t=obj.dict.get(PDFName.of('Subtype'));
      if(String(t)==='/EmbeddedFile'){
        const bytes = obj.getContents ? obj.getContents() : obj.contents;
        if(bytes){
          const u8 = bytes instanceof Uint8Array? bytes : new Uint8Array(bytes);
          if(u8.length>8 && u8[0]==0x89 && u8[1]==0x50) return u8; // PNG
          if(u8.length>3 && u8[0]==0xFF && u8[1]==0xD8) return u8; // JPEG
        }
      }
    }
  }
  return null;
}
async function analyzeImageU8(u8){
  try{
    // try PNG
    const url = URL.createObjectURL(new Blob([u8],{type:'image/png'}));
    const img = await dataURLtoImage(url); URL.revokeObjectURL(url);
    const c=document.createElement('canvas'); c.width=img.naturalWidth||img.width; c.height=img.naturalHeight||img.height;
    const x=c.getContext('2d',{willReadFrequently:true}); x.drawImage(img,0,0);
    const d=x.getImageData(0,0,c.width,c.height).data;
    const rgba = await hashRGBA(d); const rgb = await hashRGB(d); const tag = extractLSB(x);
    return {rgba,rgb,tag};
  }catch{
    try{
      const url = URL.createObjectURL(new Blob([u8],{type:'image/jpeg'}));
      const img = await dataURLtoImage(url); URL.revokeObjectURL(url);
      const c=document.createElement('canvas'); c.width=img.naturalWidth||img.width; c.height=img.naturalHeight||img.height;
      const x=c.getContext('2d',{willReadFrequently:true}); x.drawImage(img,0,0);
      const d=x.getImageData(0,0,c.width,c.height).data;
      const rgba = await hashRGBA(d); const rgb = await hashRGB(d); const tag = extractLSB(x);
      return {rgba,rgb,tag};
    }catch{ return null; }
  }
}
async function extractPrimaryImage(pdf, types){
  const { PDFName, PDFDict, PDFStream, PDFRawStream } = types;
  // scan first page resources XObject
  const page = pdf.getPages()[0];
  const Res = page?.node?.Resources && page.node.Resources();
  if(Res){
    const XObj = Res.lookup && Res.lookup(PDFName.of('XObject'), PDFDict);
    if(XObj){
      for(const k of (XObj.keys? XObj.keys():[])){
        let obj = XObj.lookup ? XObj.lookup(k) : XObj.get(k);
        if(obj && pdf.context.lookup) obj = pdf.context.lookup(obj);
        if(obj && (obj instanceof PDFStream || obj instanceof PDFRawStream)){
          const st = obj.dict.get && obj.dict.get(PDFName.of('Subtype'));
          if(String(st)==='/Image'){
            const w = num(obj.dict.get(PDFName.of('Width')));
            const h = num(obj.dict.get(PDFName.of('Height')));
            const bpc = num(obj.dict.get(PDFName.of('BitsPerComponent'))) || 8;
            const cs = String(obj.dict.get(PDFName.of('ColorSpace'))||'');
            const comps = /DeviceCMYK/.test(cs)?4 : /DeviceGray/.test(cs)?1 : 3;
            const bytes = obj.getContents? obj.getContents(): obj.contents;
            if(bytes) return {kind:'raw',w,h,bpc,comps,bytes: bytes instanceof Uint8Array? bytes: new Uint8Array(bytes)};
          }
        }
      }
    }
  }
  // fallback scan all
  for(const [ref,obj] of pdf.context.enumerateIndirectObjects()){
    if(obj && (obj instanceof types.PDFStream || obj instanceof types.PDFRawStream)){
      const st = obj.dict.get && obj.dict.get(types.PDFName.of('Subtype'));
      if(String(st)==='/Image'){
        const w = num(obj.dict.get(types.PDFName.of('Width')));
        const h = num(obj.dict.get(types.PDFName.of('Height')));
        const bpc = num(obj.dict.get(types.PDFName.of('BitsPerComponent')))||8;
        const cs = String(obj.dict.get(types.PDFName.of('ColorSpace'))||'');
        const comps = /DeviceCMYK/.test(cs)?4 : /DeviceGray/.test(cs)?1 : 3;
        const bytes = obj.getContents? obj.getContents(): obj.contents;
        if(bytes) return {kind:'raw',w,h,bpc,comps,bytes: bytes instanceof Uint8Array? bytes: new Uint8Array(bytes)};
      }
    }
  }
  return null;
}
function num(x){ if(x==null) return null; const s=String(x).replace(/[^\d.]/g,''); const n=+s; return Number.isFinite(n)?n:null; }
async function rasterOnly(info){
  if(!info || info.kind!=='raw' || info.bpc!==8) return null;
  const {w,h,comps,bytes} = info;
  const c=document.createElement('canvas'); c.width=w; c.height=h;
  const x=c.getContext('2d',{willReadFrequently:true});
  const img = x.createImageData(w,h); const d=img.data;
  for(let i=0,si=0;i<w*h;i++){
    if(comps===3){ d[4*i]=bytes[si++]; d[4*i+1]=bytes[si++]; d[4*i+2]=bytes[si++]; d[4*i+3]=255; }
    else if(comps===1){ const g=bytes[si++]; d[4*i]=g; d[4*i+1]=g; d[4*i+2]=g; d[4*i+3]=255; }
    else if(comps===4){ // naive CMYK->RGB
      const C=bytes[si++]/255, M=bytes[si++]/255, Y=bytes[si++]/255, K=bytes[si++]/255;
      d[4*i]   = 255*(1 - Math.min(1, C*(1-K)+K))|0;
      d[4*i+1] = 255*(1 - Math.min(1, M*(1-K)+K))|0;
      d[4*i+2] = 255*(1 - Math.min(1, Y*(1-K)+K))|0;
      d[4*i+3] = 255;
    }else return null;
  }
  x.putImageData(img,0,0);
  const rgba = await hashRGBA(d), rgb = await hashRGB(d);
  const tag = extractLSB(x);
  return {rgba,rgb,tag};
}
async function rasterAndRead(info){
  const r = await rasterOnly(info);
  if(!r) return null;
  // parse embedded JSON if present in tag content
  let embeddedJSON=null;
  if(r.tag){
    const m = r.tag.match(/CCJSON:([A-Za-z0-9+/=]+)/);
    if(m){ try{ embeddedJSON = JSON.parse(dec(b64toU8(m[1]))); }catch{} }
  }
  return {embeddedJSON, rgba:r.rgba, rgb:r.rgb, tag:r.tag};
}

/* ========== INIT ========== */
function genSerial(){ inputs.serial.value = `SN-${Date.now()}-${Math.random().toString(36).slice(2,11).toUpperCase()}`; }
function today(){ const d=new Date(); const y=d.getFullYear(); const m=String(d.getMonth()+1).padStart(2,'0'); const da=String(d.getDate()).padStart(2,'0'); return `${y}-${m}-${da}` }

function init(){
  inputs.date.value = today();
  genSerial();
  setDefaults();
  setBgDataURL('image.png','image.png'); // try to load; fine if 404
  regenQR();
  redraw(); fit();

  // theme
  on($('theme'),'click',()=>{ const t=document.documentElement.getAttribute('data-theme')==='dark'?'light':'dark'; document.documentElement.setAttribute('data-theme',t); $('theme').textContent = t==='dark'?'☀️':'🌙'; redraw(); });
  // tabs
  document.querySelectorAll('.tab').forEach(btn=>{
    on(btn,'click',()=>{
      document.querySelectorAll('.tab').forEach(b=>b.classList.remove('active')); btn.classList.add('active');
      const tgt = btn.dataset.tab;
      document.querySelectorAll('.pane').forEach(p=>p.classList.remove('active'));
      (tgt==='gen'?$('pane-gen'):$('pane-ver')).classList.add('active');
    });
  });
  // files
  on($('bg-file'),'change',e=>handleBgFile(e.target.files?.[0]));
  on($('logo-file'),'change',e=>handleLogoFile(e.target.files?.[0]));
  // gen
  on($('regen'),'click',()=>{ genSerial(); regenQR(); redraw(); });
  on($('align-x'),'click',()=>{ inputs.xType.value=inputs.xAmt.value; redraw(); });
  on($('reset-pos'),'click',()=>resetPositions());
  on($('reset-qr'),'click',()=>{ inputs.xQR.value=Math.max(0,(cv.width- state.qr.size - 50)); inputs.yQR.value=Math.max(0,(cv.height- state.qr.size - 50)); redraw(); });
  Object.values(inputs).forEach(el=> on(el,'input',deb(()=>{ if(el===inputs.qrMode) regenQR(); redraw(); },20)));
  // zoom
  on($('z+'),'click',()=>applyZoom(.2)); on($('z-'),'click',()=>applyZoom(-.2));
  // export
  on($('export'),'click',exportPDF);
  // verify
  on($('ver-file'),'change',e=>verifyPDF(e.target.files?.[0]));
  on($('copy-diag'),'click',async()=>{ try{await navigator.clipboard.writeText($('diag').textContent||''); alert('Diagnostics copied.');}catch{alert('Copy failed');} });
  // errors
  on($('eclose'),'click',()=>$('emodal').style.display='none');

  // quick-scan via URL (?verify=)
  const qs=new URLSearchParams(location.search).get('verify');
  if(qs){ document.querySelector('.tab[data-tab="ver"]').click(); }
}
window.addEventListener('load', init);
</script>
</body>
</html>
